---
phase: 02-chunk-claiming-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/thc/claim/ClaimData.kt
  - src/main/kotlin/thc/claim/ClaimManager.kt
  - src/main/kotlin/thc/THC.kt
autonomous: true

must_haves:
  truths:
    - "Claimed chunks persist across server restarts"
    - "ClaimManager can query if a chunk is claimed"
    - "ClaimManager can add a claim for a chunk"
  artifacts:
    - path: "src/main/kotlin/thc/claim/ClaimData.kt"
      provides: "PersistentState for world-level claim storage"
      contains: "PersistentState"
    - path: "src/main/kotlin/thc/claim/ClaimManager.kt"
      provides: "Claim query and mutation API"
      exports: ["isClaimed", "addClaim", "getBaseFloorY"]
  key_links:
    - from: "ClaimManager"
      to: "ClaimData"
      via: "PersistentStateManager.getOrCreate()"
      pattern: "getOrCreate"
    - from: "THC.kt"
      to: "ClaimManager"
      via: "initialization call in onInitialize"
---

<objective>
Create persistent storage and API for tracking claimed chunks across server sessions.

Purpose: Foundation layer that stores which chunks are claimed and provides query API for future phases (base permissions, placement restrictions).
Output: ClaimData PersistentState with codec, ClaimManager singleton with query/mutation methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-land-plot-system/01-02-SUMMARY.md

# Key source files for patterns:
@src/main/java/thc/THCAttachments.java
@src/main/kotlin/thc/THC.kt
@src/main/kotlin/thc/bell/BellState.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaimData PersistentState with codec</name>
  <files>src/main/kotlin/thc/claim/ClaimData.kt</files>
  <action>
Create ClaimData class extending PersistentState for storing claimed chunk data.

Requirements:
- Store claimed chunks as a Set of ChunkPos (converted to long for codec)
- Store base floor Y for each claimed chunk (lowest surface Y - 10) in a Map<Long, Int>
- Use Codec pattern for serialization (see Fabric PersistentState wiki)
- Implement companion object with:
  - `type: PersistentStateType<ClaimData>` with mod ID "thc_claims"
  - `getServerState(server: MinecraftServer): ClaimData` that uses World.OVERWORLD

Codec structure:
```kotlin
private val CODEC: Codec<ClaimData> = RecordCodecBuilder.create { instance ->
    instance.group(
        Codec.LONG.listOf().fieldOf("claimed_chunks").forGetter { it.claimedChunks.toList() },
        Codec.unboundedMap(Codec.STRING, Codec.INT).fieldOf("base_floors").forGetter {
            it.baseFloors.mapKeys { (k, _) -> k.toString() }
        }
    ).apply(instance) { chunks, floors ->
        ClaimData().apply {
            claimedChunks.addAll(chunks)
            floors.forEach { (k, v) -> baseFloors[k.toLong()] = v }
        }
    }
}
```

Key imports:
- net.minecraft.world.level.saveddata.SavedData (Mojang mappings for PersistentState)
- net.minecraft.server.MinecraftServer
- net.minecraft.world.level.Level
- com.mojang.serialization.Codec
- com.mojang.serialization.codecs.RecordCodecBuilder

Note: In Mojang mappings, PersistentState is called SavedData.
  </action>
  <verify>Build succeeds: `./gradlew build`</verify>
  <done>ClaimData class exists with codec serialization and type registration</done>
</task>

<task type="auto">
  <name>Task 2: Create ClaimManager singleton with claim API</name>
  <files>src/main/kotlin/thc/claim/ClaimManager.kt, src/main/kotlin/thc/THC.kt</files>
  <action>
Create ClaimManager object that provides the claim query and mutation API.

ClaimManager methods:
- `isClaimed(server: MinecraftServer, chunkPos: ChunkPos): Boolean` - Check if chunk is claimed
- `addClaim(server: MinecraftServer, chunkPos: ChunkPos, baseFloorY: Int): Boolean` - Add claim, returns true on success
- `getBaseFloorY(server: MinecraftServer, chunkPos: ChunkPos): Int?` - Get base floor Y for claimed chunk, null if not claimed
- `isInBase(server: MinecraftServer, pos: BlockPos): Boolean` - Check if position is within a base area (y >= baseFloorY for that chunk)

Implementation notes:
- All methods should call `ClaimData.getServerState(server)` to get current state
- Use `chunkPos.toLong()` for storage key
- After mutations, call `markDirty()` on the ClaimData
- `isInBase` needs to check: chunk is claimed AND pos.y >= baseFloorY for that chunk

Register in THC.kt onInitialize (no actual initialization needed, just ensure package is loaded):
```kotlin
// ClaimManager is a stateless object, no init needed
```

Actually, no registration needed since ClaimManager is stateless and ClaimData uses lazy getOrCreate pattern.
  </action>
  <verify>Build succeeds: `./gradlew build`</verify>
  <done>ClaimManager provides isClaimed, addClaim, getBaseFloorY, isInBase methods</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] ClaimData.kt compiles with SavedData/PersistentState extension
- [ ] ClaimManager.kt compiles with all required methods
- [ ] No TypeScript/Kotlin errors in claim package
</verification>

<success_criteria>

- ClaimData class extends SavedData with working codec
- ClaimManager provides query API (isClaimed, isInBase)
- ClaimManager provides mutation API (addClaim)
- Base floor Y stored per chunk for future permission checks
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-chunk-claiming-core/02-01-SUMMARY.md`
</output>
