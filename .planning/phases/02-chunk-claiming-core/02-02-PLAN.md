---
phase: 02-chunk-claiming-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/thc/claim/ChunkValidator.kt
autonomous: true

must_haves:
  truths:
    - "Terrain flatness check returns false for chunks with >10 block Y difference"
    - "Village detection returns true for chunks containing village structures"
    - "Validation calculates correct lowest surface Y for base floor"
  artifacts:
    - path: "src/main/kotlin/thc/claim/ChunkValidator.kt"
      provides: "Chunk validation for terrain and village checks"
      exports: ["validateTerrain", "isVillageChunk", "ValidationResult"]
  key_links:
    - from: "ChunkValidator.validateTerrain"
      to: "level.getHeight()"
      via: "Heightmap.Types.WORLD_SURFACE"
      pattern: "getHeight.*WORLD_SURFACE"
    - from: "ChunkValidator.isVillageChunk"
      to: "structureManager"
      via: "getStructureWithPieceAt or getStructureAt"
---

<objective>
Create chunk validation logic for terrain flatness and village detection.

Purpose: Enforce claiming rules - chunks must have flat terrain and cannot be village chunks.
Output: ChunkValidator object with terrain and village validation methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Reference for Minecraft APIs:
# - Heightmap: level.getHeight(Heightmap.Types.WORLD_SURFACE, x, z)
# - Structure: level.structureManager().getStructureWithPieceAt(pos, structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChunkValidator with terrain flatness check</name>
  <files>src/main/kotlin/thc/claim/ChunkValidator.kt</files>
  <action>
Create ChunkValidator object with terrain flatness validation.

Define ValidationResult sealed class:
```kotlin
sealed class ValidationResult {
    data class Success(val lowestSurfaceY: Int) : ValidationResult()
    data class Failure(val reason: String) : ValidationResult()
}
```

Implement validateTerrain method:
```kotlin
fun validateTerrain(level: ServerLevel, chunkPos: ChunkPos): ValidationResult
```

Algorithm for terrain flatness (CLAIM-02):
1. Get chunk bounds: startX = chunkPos.minBlockX, startZ = chunkPos.minBlockZ
2. Iterate all 256 surface positions (16x16 chunk)
3. For each (x, z), get surface Y: `level.getHeight(Heightmap.Types.WORLD_SURFACE, x, z) - 1`
   Note: getHeight returns Y of first air block, so subtract 1 for actual surface
4. Track minY and maxY across all positions
5. If (maxY - minY) > 10: return Failure("The chunk's surface is not flat enough!")
6. Otherwise: return Success(lowestSurfaceY = minY)

Key imports:
- net.minecraft.server.level.ServerLevel
- net.minecraft.world.level.ChunkPos
- net.minecraft.world.level.levelgen.Heightmap
  </action>
  <verify>Build succeeds: `./gradlew build`</verify>
  <done>ChunkValidator.validateTerrain returns Success with lowestSurfaceY or Failure with message</done>
</task>

<task type="auto">
  <name>Task 2: Add village detection to ChunkValidator</name>
  <files>src/main/kotlin/thc/claim/ChunkValidator.kt</files>
  <action>
Add isVillageChunk method to ChunkValidator.

```kotlin
fun isVillageChunk(level: ServerLevel, chunkPos: ChunkPos): Boolean
```

Implementation approach for village detection (CLAIM-08):
1. Get the village structure from registry: `level.registryAccess().lookupOrThrow(Registries.STRUCTURE).get(BuiltinStructures.VILLAGE_PLAINS)`
   Note: Need to check multiple village types or use tag
2. Better approach - check if ANY structure piece at chunk center:
   ```kotlin
   val centerPos = BlockPos(chunkPos.middleBlockX, 64, chunkPos.middleBlockZ)
   val structureManager = level.structureManager()

   // Check for village structures using structure tag or individual lookups
   val villageTypes = listOf(
       BuiltinStructures.VILLAGE_PLAINS,
       BuiltinStructures.VILLAGE_DESERT,
       BuiltinStructures.VILLAGE_SAVANNA,
       BuiltinStructures.VILLAGE_SNOWY,
       BuiltinStructures.VILLAGE_TAIGA
   )

   for (villageType in villageTypes) {
       val structureKey = level.registryAccess()
           .lookupOrThrow(Registries.STRUCTURE)
           .get(villageType)
       if (structureKey != null) {
           val structure = structureKey.value()
           val start = structureManager.getStructureWithPieceAt(centerPos, structure)
           if (start.isValid) return true
       }
   }
   ```

3. Alternative simpler approach - iterate all positions in chunk and check:
   ```kotlin
   // Check multiple Y levels and positions within chunk
   for (x in 0..15) {
       for (z in 0..15) {
           val pos = BlockPos(chunkPos.minBlockX + x, 64, chunkPos.minBlockZ + z)
           // structureManager check
       }
   }
   ```

Actually, simplest reliable approach:
- Use `structureManager.getAllStructuresAt(pos)` and check if any are village type
- Or use `structureManager.hasAnyStructureAt(pos)` with village filter

Key imports:
- net.minecraft.core.BlockPos
- net.minecraft.core.registries.Registries
- net.minecraft.world.level.levelgen.structure.BuiltinStructures
- net.minecraft.world.level.StructureManager (access via level.structureManager())

Note: The exact API depends on Minecraft 1.21.11 - verify method names compile.
  </action>
  <verify>Build succeeds: `./gradlew build`</verify>
  <done>ChunkValidator.isVillageChunk returns true for village chunks</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] ChunkValidator.kt compiles with validateTerrain method
- [ ] ChunkValidator.kt compiles with isVillageChunk method
- [ ] ValidationResult sealed class properly defined
</verification>

<success_criteria>

- ChunkValidator.validateTerrain calculates terrain flatness correctly
- Terrain check enforces max 10 block Y difference (CLAIM-02)
- ChunkValidator.isVillageChunk detects all village types (CLAIM-08)
- ValidationResult.Success includes lowestSurfaceY for base floor calculation (CLAIM-07)
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-chunk-claiming-core/02-02-SUMMARY.md`
</output>
