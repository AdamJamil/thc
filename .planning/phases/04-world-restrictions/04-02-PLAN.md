---
phase: 04-world-restrictions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/thc/world/MiningFatigue.kt
  - src/main/kotlin/thc/THC.kt
autonomous: true

must_haves:
  truths:
    - "Player receives mining fatigue when breaking blocks outside base (non-village)"
    - "Mining fatigue stacks with 1.4^x multiplier for break time"
    - "Mining fatigue decays one level every 12 seconds"
    - "Mining fatigue displays 12 seconds remaining duration per level"
  artifacts:
    - path: "src/main/kotlin/thc/world/MiningFatigue.kt"
      provides: "Mining fatigue effect application, stacking, and decay"
      min_lines: 60
      contains: "MobEffects.DIG_SLOWDOWN"
  key_links:
    - from: "MiningFatigue.kt"
      to: "ClaimManager.isInBase"
      via: "base area check"
      pattern: "ClaimManager\\.isInBase"
    - from: "MiningFatigue.kt"
      to: "PlayerBlockBreakEvents"
      via: "Fabric event registration"
      pattern: "PlayerBlockBreakEvents"
---

<objective>
Implement mining fatigue system for block breaking outside base areas.

Purpose: Make resource gathering risky - breaking blocks stacks fatigue, encouraging careful planning.
Output: MiningFatigue handler applying stacking effects with decay timer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chunk-claiming-core/02-01-SUMMARY.md

@src/main/kotlin/thc/claim/ClaimManager.kt
@src/main/kotlin/thc/claim/ChunkValidator.kt
@src/main/kotlin/thc/THC.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MiningFatigue handler with effect application</name>
  <files>src/main/kotlin/thc/world/MiningFatigue.kt</files>
  <action>
Create MiningFatigue singleton object:

1. Constants:
   - DECAY_TICKS = 12 * 20 (12 seconds = 240 ticks)
   - This is the duration displayed and the time per level decay

2. register() function:
   - Register PlayerBlockBreakEvents.BEFORE event handler
   - Handler parameters: (level, player, pos, state, blockEntity)
   - Return true to allow break, false to cancel

3. Handler logic:
   a. Skip if level.isClientSide (should already be ServerLevel for BEFORE, but be safe)
   b. Cast to ServerLevel, get server
   c. Check if player is in base: ClaimManager.isInBase(server, pos)
      - If in base: return true (allow, no fatigue - BREAK-03 implicitly covered by BASE-02)
   d. Check if chunk is village: ChunkValidator.isVillageChunk(level, ChunkPos(pos))
      - If village: return true (village protection handled by Plan 03, don't apply fatigue)
   e. Apply/stack mining fatigue (call applyFatigue function)
   f. Return true (allow the break - fatigue makes it slow, doesn't prevent)

4. applyFatigue(player: ServerPlayer) function:
   - Get current fatigue effect: player.getEffect(MobEffects.DIG_SLOWDOWN)
   - If no effect: apply amplifier 0 (Fatigue I) for DECAY_TICKS duration
   - If has effect:
     - Get current amplifier
     - Remove old effect
     - Apply new effect with amplifier+1 for DECAY_TICKS duration
   - Use player.addEffect(MobEffectInstance(MobEffects.DIG_SLOWDOWN, duration, amplifier))

Note on stacking formula (BREAK-02):
The vanilla DIG_SLOWDOWN effect already slows mining. The "1.4^x times longer" is achieved by
stacking amplifiers. Each amplifier level adds to the slowdown. The exact 1.4^x formula may need
custom implementation if vanilla amplifiers don't match, but start with vanilla stacking and
verify in testing.

Import: net.minecraft.world.effect.MobEffects, MobEffectInstance
  </action>
  <verify>./gradlew build compiles without errors</verify>
  <done>MiningFatigue.kt exists with PlayerBlockBreakEvents handler and applyFatigue function</done>
</task>

<task type="auto">
  <name>Task 2: Register MiningFatigue in mod initializer</name>
  <files>src/main/kotlin/thc/THC.kt</files>
  <action>
Update THC.kt:
1. Add import for thc.world.MiningFatigue
2. In onInitialize(), add MiningFatigue.register() call after other register() calls

Registration order in onInitialize should be:
- BellHandler.register()
- BasePermissions.register()
- MiningFatigue.register() (new)
- WorldRestrictions.register() (from Plan 01, if already present)
  </action>
  <verify>./gradlew build compiles without errors; grep -q "MiningFatigue.register" src/main/kotlin/thc/THC.kt</verify>
  <done>MiningFatigue registered in mod initialization chain</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] MiningFatigue.kt contains PlayerBlockBreakEvents.BEFORE handler
- [ ] Handler checks isInBase and isVillageChunk before applying fatigue
- [ ] applyFatigue stacks amplifier levels with 12-second duration
- [ ] THC.kt calls MiningFatigue.register()
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compilation errors
- Mining fatigue system ready for in-game testing (BREAK-01 through BREAK-04)
</success_criteria>

<output>
After completion, create `.planning/phases/04-world-restrictions/04-02-SUMMARY.md`
</output>
