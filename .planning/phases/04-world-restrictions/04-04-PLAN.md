---
phase: 04-world-restrictions
plan: 04
type: execute
wave: 1
depends_on: ["04-02"]
files_modified:
  - src/main/kotlin/thc/world/MiningFatigue.kt
autonomous: true

must_haves:
  truths:
    - "Mining fatigue decays one level every 12 seconds (Fatigue III → II → I → gone)"
    - "Player with Mining Fatigue III who stops mining has Fatigue II after 12 seconds"
    - "Effect duration always shows ~12 seconds (current level's remaining time)"
  artifacts:
    - path: "src/main/kotlin/thc/world/MiningFatigue.kt"
      provides: "Tick handler for fatigue decay with level-by-level reduction"
      contains: "ServerTickEvents"
  key_links:
    - from: "MiningFatigue.kt tick handler"
      to: "player effect tracking"
      via: "check expiring effects and reapply at lower level"
      pattern: "ServerTickEvents"
---

<objective>
Fix mining fatigue decay to properly reduce one level every 12 seconds.

Purpose: BREAK-03 requires fatigue to decay level-by-level (III→II→I→gone), but current implementation just removes the effect entirely when duration expires.
Output: Tick-based decay handler that reapplies effect at one level lower when duration expires.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-world-restrictions/04-02-SUMMARY.md

@src/main/kotlin/thc/world/MiningFatigue.kt
@src/main/kotlin/thc/THC.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tick-based fatigue decay handler</name>
  <files>src/main/kotlin/thc/world/MiningFatigue.kt</files>
  <action>
Add a tick handler to implement proper level-by-level decay:

1. Track players with mining fatigue:
   - Store Map<UUID, Int> of player UUID to their fatigue amplifier when applied
   - Update this map whenever applyFatigue() is called

2. Register ServerTickEvents.END_SERVER_TICK handler in register():
   - For each player on the server
   - Check if player has mining fatigue effect
   - If effect exists AND remaining duration <= 1 tick (about to expire):
     - Get current amplifier from effect
     - If amplifier > 0 (Fatigue II or higher):
       - Remove effect
       - Apply new effect with amplifier-1 and DECAY_TICKS duration
     - If amplifier == 0 (Fatigue I):
       - Let it expire naturally (do nothing, effect will be removed by game)
   - Clean up tracking map when player has no effect

3. Implementation approach:
   - Use server.playerList.players to iterate all players
   - Check effect.duration <= 1 to catch imminent expiration
   - player.removeEffect(MobEffects.MINING_FATIGUE) before reapplying
   - player.addEffect(MobEffectInstance(MobEffects.MINING_FATIGUE, DECAY_TICKS, newAmplifier))

Import: net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
  </action>
  <verify>./gradlew build compiles without errors</verify>
  <done>Tick handler implemented that decays fatigue one level every 12 seconds</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] ServerTickEvents.END_SERVER_TICK registered in MiningFatigue.register()
- [ ] Handler checks for expiring mining fatigue and reapplies at lower level
- [ ] Amplifier 0 (Fatigue I) is allowed to expire naturally
</verification>

<success_criteria>
- Task completed
- All verification checks pass
- No compilation errors
- Mining fatigue decay behavior matches BREAK-03 requirement
</success_criteria>

<output>
After completion, create `.planning/phases/04-world-restrictions/04-04-SUMMARY.md`
</output>
