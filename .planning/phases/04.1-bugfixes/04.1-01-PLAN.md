---
phase: 04.1-bugfixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/resources/assets/thc/items/land_plot.json
  - src/main/kotlin/thc/bell/BellProtection.kt
  - src/main/kotlin/thc/THC.kt
  - src/main/kotlin/thc/world/WorldRestrictions.kt
  - src/main/kotlin/thc/claim/ChunkValidator.kt
autonomous: true
must_haves:
  truths:
    - "Land plot item displays correct custom texture in inventory and hand"
    - "Bells cannot be broken by players"
    - "Block placement rejection does not desync inventory"
    - "Blocks cannot be broken in village chunks (except ores and allowlist)"
  artifacts:
    - path: "src/main/resources/assets/thc/items/land_plot.json"
      provides: "Item definition file for Minecraft 1.21+ item model system"
    - path: "src/main/kotlin/thc/bell/BellProtection.kt"
      provides: "Block break handler preventing bell destruction"
    - path: "src/main/kotlin/thc/world/WorldRestrictions.kt"
      provides: "Fixed placement rejection that syncs inventory"
    - path: "src/main/kotlin/thc/claim/ChunkValidator.kt"
      provides: "Improved village detection using chunk-based structure lookup"
  key_links:
    - from: "THC.kt"
      to: "BellProtection.register()"
      via: "mod initialization"
      pattern: "BellProtection\\.register\\(\\)"
---

<objective>
Fix four bugs discovered during gameplay testing before Phase 5 testing begins.

Purpose: Ensure core mechanics work correctly so Phase 5 tests can validate expected behavior.
Output: Working fixes for land plot icon, bell protection, inventory sync, and village protection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementations to fix:
@src/main/kotlin/thc/item/THCItems.kt
@src/main/kotlin/thc/world/WorldRestrictions.kt
@src/main/kotlin/thc/claim/ChunkValidator.kt
@src/main/kotlin/thc/bell/BellHandler.kt
@src/main/kotlin/thc/THC.kt
@src/main/resources/assets/thc/models/item/land_plot.json

# Reference for item definition pattern:
@src/main/resources/assets/thc/items/stone_buckler.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add land_plot item definition file</name>
  <files>src/main/resources/assets/thc/items/land_plot.json</files>
  <action>
Create the item definition file for land_plot that Minecraft 1.21+ requires.

In MC 1.21+, items need both:
1. A model definition in `models/item/{name}.json` (exists at `models/item/land_plot.json`)
2. An item definition in `items/{name}.json` (MISSING - this is the bug)

Create `src/main/resources/assets/thc/items/land_plot.json`:
```json
{
  "model": {
    "type": "minecraft:model",
    "model": "thc:item/land_plot"
  }
}
```

This is a simple item (no conditions like buckler's "using_item" check), so it just references the model directly.

The existing model at `models/item/land_plot.json` already references `thc:item/land_plot` texture which points to `textures/item/land_plot.png`.
  </action>
  <verify>File exists and is valid JSON</verify>
  <done>Land plot item has item definition file matching 1.21+ requirements</done>
</task>

<task type="auto">
  <name>Task 2: Add bell break protection handler</name>
  <files>src/main/kotlin/thc/bell/BellProtection.kt, src/main/kotlin/thc/THC.kt</files>
  <action>
Create a new handler to prevent bells from being broken.

1. Create `src/main/kotlin/thc/bell/BellProtection.kt`:
```kotlin
package thc.bell

import net.fabricmc.fabric.api.event.player.PlayerBlockBreakEvents
import net.minecraft.world.level.block.Blocks

/**
 * Prevents players from breaking bells.
 *
 * Bells are critical infrastructure for obtaining land plots.
 * They must remain permanent world fixtures.
 */
object BellProtection {

    fun register() {
        PlayerBlockBreakEvents.BEFORE.register { level, player, pos, state, blockEntity ->
            // Allow break on client side (server will reject)
            if (level.isClientSide) {
                return@register true
            }

            // Block breaking bells
            if (state.`is`(Blocks.BELL)) {
                return@register false
            }

            // Allow all other blocks
            true
        }
    }
}
```

2. Register in THC.kt onInitialize(), add BEFORE BellHandler.register() so protection is registered first:
   - Add import: `import thc.bell.BellProtection`
   - Add registration call: `BellProtection.register()` before `BellHandler.register()`

The handler should be registered EARLY in the event chain so bells are protected from all break attempts.
  </action>
  <verify>BellProtection.kt compiles, THC.kt includes registration</verify>
  <done>Bell break events are intercepted and blocked</done>
</task>

<task type="auto">
  <name>Task 3: Fix block placement inventory desync</name>
  <files>src/main/kotlin/thc/world/WorldRestrictions.kt</files>
  <action>
Fix the inventory desync when placement is rejected.

The problem: Returning `InteractionResult.FAIL` causes client-server desync because the client predicts success before server rejects. The item count decrements on client, then later corrects.

The solution: After returning FAIL, manually sync the player's inventory slot.

In WorldRestrictions.kt, modify the register() function:

1. When rejecting non-allowlist blocks (around line 113), after returning FAIL, sync the slot:
```kotlin
if (block !in ALLOWED_BLOCKS) {
    // Sync inventory to fix client-side prediction desync
    player.containerMenu.sendAllDataToRemote()
    return@UseBlockCallback InteractionResult.FAIL
}
```

2. When rejecting adjacency violations (around line 119), same fix:
```kotlin
if (!checkAdjacency(level, placementPos)) {
    // Sync inventory to fix client-side prediction desync
    player.containerMenu.sendAllDataToRemote()
    return@UseBlockCallback InteractionResult.FAIL
}
```

Note: `player.containerMenu.sendAllDataToRemote()` sends all inventory data back to the client, ensuring the item stack count is corrected immediately rather than on next interaction.

Alternative: Could use `player.inventoryMenu.broadcastChanges()` but `sendAllDataToRemote()` is more reliable for immediate sync.
  </action>
  <verify>./gradlew build succeeds</verify>
  <done>Block placement rejection properly syncs inventory without visual desync</done>
</task>

<task type="auto">
  <name>Task 4: Fix village chunk detection</name>
  <files>src/main/kotlin/thc/claim/ChunkValidator.kt</files>
  <action>
Fix village detection to properly find village structures.

The current implementation samples specific positions and Y-levels looking for structure pieces. This fails because:
1. Village structures may not have pieces at the sampled positions
2. The method `getStructureWithPieceAt` only returns true if a structure PIECE exists at that exact position

Better approach: Use `structureManager.startsForStructure()` or check if any structure start is in the chunk.

In ChunkValidator.kt, replace the `isVillageChunk` function:

```kotlin
/**
 * Checks if a chunk contains any village structure.
 *
 * Uses chunk-level structure access to detect villages reliably.
 * Checks for any structure tagged as VILLAGE that starts in this chunk.
 *
 * @param level The server level to check
 * @param chunkPos The chunk position to validate
 * @return true if the chunk contains or is part of a village structure
 */
fun isVillageChunk(level: ServerLevel, chunkPos: ChunkPos): Boolean {
    val structureManager = level.structureManager()
    val chunk = level.getChunk(chunkPos.x, chunkPos.z)

    // Check all structure starts in this chunk
    val structureStarts = chunk.allStarts

    for ((structure, structureStart) in structureStarts) {
        // Check if this structure is tagged as a village
        val structureKey = level.registryAccess()
            .lookupOrThrow(net.minecraft.core.registries.Registries.STRUCTURE)
            .getKey(structure)

        if (structureKey != null) {
            val holder = level.registryAccess()
                .lookupOrThrow(net.minecraft.core.registries.Registries.STRUCTURE)
                .get(structureKey)

            if (holder.isPresent && holder.get().`is`(StructureTags.VILLAGE)) {
                return true
            }
        }
    }

    // Also check if any village structure EXTENDS into this chunk (not just starts here)
    // Use position sampling for structure pieces that might span from neighboring chunks
    val centerPos = BlockPos(chunkPos.middleBlockX, 64, chunkPos.middleBlockZ)
    val structureAt = structureManager.getStructureWithPieceAt(centerPos, StructureTags.VILLAGE)
    if (structureAt.isValid) {
        return true
    }

    return false
}
```

Add import if needed: `import net.minecraft.core.BlockPos`

This approach:
1. First checks if any village structure STARTS in this chunk (catches structure origin chunks)
2. Then checks if a village structure piece EXISTS at chunk center (catches chunks that villages extend into)
  </action>
  <verify>./gradlew build succeeds</verify>
  <done>Village chunks are reliably detected for protection</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] `src/main/resources/assets/thc/items/land_plot.json` exists with correct structure
- [ ] `src/main/kotlin/thc/bell/BellProtection.kt` exists and is registered
- [ ] WorldRestrictions.kt includes inventory sync after FAIL returns
- [ ] ChunkValidator.kt uses improved village detection
</verification>

<success_criteria>
- All tasks completed
- Build succeeds
- All four bugs have code fixes in place
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-bugfixes/04.1-01-SUMMARY.md`
</output>
