---
phase: 04.2-bugfixes-2
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/thc/claim/ChunkValidator.kt
  - src/main/kotlin/thc/mixin/BellBlockMixin.java
  - src/main/resources/thc.mixins.json
  - src/main/kotlin/thc/THC.kt
autonomous: true
must_haves:
  truths:
    - "Bells have bedrock-like hardness and cannot be broken by players"
    - "Blocks cannot be broken in village chunks (except ores and allowlist)"
  artifacts:
    - path: "src/main/kotlin/thc/mixin/BellBlockMixin.java"
      provides: "Mixin that sets bell destroy time to extreme value"
    - path: "src/main/kotlin/thc/claim/ChunkValidator.kt"
      provides: "Improved village detection using full-chunk structure reference scan"
  key_links:
    - from: "thc.mixins.json"
      to: "BellBlockMixin"
      via: "mixin registration"
      pattern: "BellBlockMixin"
---

<objective>
Fix two critical bugs discovered during gameplay testing:
1. Bells can be broken (they reappear but should be unbreakable like bedrock)
2. Village chunk detection fails - blocks can still be broken in villages

Purpose: Ensure core mechanics work correctly before Phase 5 automated testing.
Output: Working bell protection via mixin, reliable village chunk detection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current implementations to fix:
@src/main/kotlin/thc/claim/ChunkValidator.kt
@src/main/kotlin/thc/bell/BellProtection.kt
@src/main/kotlin/thc/THC.kt
@src/main/resources/thc.mixins.json

# Reference for mixin pattern:
@src/main/java/thc/mixin/LivingEntityMixin.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BellBlockMixin for bedrock-like hardness</name>
  <files>src/main/java/thc/mixin/BellBlockMixin.java, src/main/resources/thc.mixins.json</files>
  <action>
Create a mixin that overrides the bell's destroy time to make it unbreakable like bedrock.

The current approach (PlayerBlockBreakEvents.BEFORE returning false) cancels the break but allows visual breaking animation. The bell "breaks" visually, then reappears. This is not bedrock behavior.

**Bedrock behavior:** Block never starts breaking animation. Mining progress bar never appears. Block is completely indestructible.

**Solution:** Mixin that injects into BellBlock to return extreme destroy time (1e6 or -1.0f).

Create `src/main/java/thc/mixin/BellBlockMixin.java`:
```java
package thc.mixin;

import net.minecraft.world.level.block.BellBlock;
import net.minecraft.world.level.block.state.BlockState;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * Makes bells indestructible like bedrock.
 *
 * Overrides getDestroyProgress to return 0 (no mining progress).
 * This prevents the mining animation from ever starting.
 */
@Mixin(BellBlock.class)
public abstract class BellBlockMixin {

    /**
     * Override destroy progress to always return 0.
     * This makes the bell appear to have infinite hardness.
     */
    @Inject(method = "getDestroyProgress", at = @At("HEAD"), cancellable = true)
    private void makeUnbreakable(BlockState state, net.minecraft.world.entity.player.Player player,
                                  net.minecraft.world.level.BlockGetter level, net.minecraft.core.BlockPos pos,
                                  CallbackInfoReturnable<Float> cir) {
        cir.setReturnValue(0.0f);
    }
}
```

**Why 0.0f:** The destroy progress represents how much the block breaks per tick. Returning 0 means zero progress, making the block unbreakable regardless of tool or enchantments.

Then update `src/main/resources/thc.mixins.json` to add the new mixin to the mixins array.
  </action>
  <verify>File exists and is valid Java, thc.mixins.json includes BellBlockMixin</verify>
  <done>Bell blocks are indestructible via mixin (bedrock-like behavior)</done>
</task>

<task type="auto">
  <name>Task 2: Remove BellProtection event handler</name>
  <files>src/main/kotlin/thc/THC.kt, src/main/kotlin/thc/bell/BellProtection.kt</files>
  <action>
Now that bells are protected via mixin, the event-based BellProtection is redundant and can cause issues.

1. Remove `BellProtection.register()` call from THC.kt onInitialize()
2. Delete the import statement for BellProtection
3. Optionally: Delete BellProtection.kt entirely (or leave it but don't register it)

The mixin approach is cleaner - it prevents the break from ever starting rather than canceling it mid-flight.
  </action>
  <verify>THC.kt does not call BellProtection.register()</verify>
  <done>BellProtection event handler removed, mixin handles protection</done>
</task>

<task type="auto">
  <name>Task 3: Fix village chunk detection with comprehensive structure scan</name>
  <files>src/main/kotlin/thc/claim/ChunkValidator.kt</files>
  <action>
The current village detection has two problems:
1. Only checks structures that START in the chunk (misses chunks villages extend INTO)
2. Only samples Y=64 at chunk center (villages can be at any Y, cover whole chunk)

Villages span multiple chunks. A village might start in chunk A but extend buildings into chunks B, C, D. The current code misses B, C, D.

**Better approach:** Use `structureManager.getStructureAt(pos, structure)` which checks if ANY piece of a structure contains the given position. Sample multiple Y levels across the chunk.

Replace the `isVillageChunk` function with:

```kotlin
/**
 * Checks if a chunk contains any village structure.
 *
 * Uses comprehensive structure detection:
 * 1. Check if any village structure STARTS in this chunk
 * 2. Check multiple positions across the chunk for village structure PIECES
 *    (villages extend across multiple chunks)
 *
 * @param level The server level to check
 * @param chunkPos The chunk position to validate
 * @return true if the chunk contains or is part of a village structure
 */
fun isVillageChunk(level: ServerLevel, chunkPos: ChunkPos): Boolean {
    val structureManager = level.structureManager()
    val chunk = level.getChunk(chunkPos.x, chunkPos.z)

    // Method 1: Check structure starts in this chunk
    for ((structure, _) in chunk.allStarts) {
        val structureKey = level.registryAccess()
            .lookupOrThrow(net.minecraft.core.registries.Registries.STRUCTURE)
            .getKey(structure)

        if (structureKey != null) {
            val holder = level.registryAccess()
                .lookupOrThrow(net.minecraft.core.registries.Registries.STRUCTURE)
                .get(structureKey)

            if (holder.isPresent && holder.get().`is`(StructureTags.VILLAGE)) {
                return true
            }
        }
    }

    // Method 2: Sample multiple positions across the chunk for structure pieces
    // Villages typically generate at ground level, but sample multiple Y levels
    // Sample a 3x3 grid of positions within the chunk, at multiple Y levels
    val yLevels = listOf(64, 70, 75, 80, 63, 60, 55)  // Common village heights + variations
    val xOffsets = listOf(2, 8, 14)  // Near edges and center
    val zOffsets = listOf(2, 8, 14)

    for (y in yLevels) {
        for (xOff in xOffsets) {
            for (zOff in zOffsets) {
                val checkPos = BlockPos(chunkPos.minBlockX + xOff, y, chunkPos.minBlockZ + zOff)
                val structureAt = structureManager.getStructureWithPieceAt(checkPos, StructureTags.VILLAGE)
                if (structureAt.isValid) {
                    return true
                }
            }
        }
    }

    return false
}
```

**Why this works:**
- `getStructureWithPieceAt` checks if a structure PIECE (not start) exists at the position
- Sampling a 3x3 grid (9 positions) at 7 Y levels (63 total checks) covers the chunk well
- If ANY part of a village is in the chunk, at least one sample will hit it
- Y levels chosen based on typical village generation heights (sea level 63 up to hills at 80)
  </action>
  <verify>./gradlew build succeeds</verify>
  <done>Village chunks are reliably detected across all chunks the village spans</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] `src/main/java/thc/mixin/BellBlockMixin.java` exists
- [ ] `thc.mixins.json` includes BellBlockMixin in mixins array
- [ ] THC.kt does not register BellProtection
- [ ] ChunkValidator.isVillageChunk uses multi-position sampling
</verification>

<success_criteria>
- All tasks completed
- Build succeeds
- Bell is unbreakable via mixin (bedrock behavior)
- Village detection samples multiple positions across chunk
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-bugfixes-2/04.2-01-SUMMARY.md`
</output>
