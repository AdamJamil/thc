---
phase: 15-threat-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/threat/ThreatManager.java
  - src/main/java/thc/THCAttachments.java
autonomous: true
must_haves:
  truths:
    - "Mobs can store threat values per-player"
    - "Threat values can be retrieved and modified"
    - "Threat map initializes empty for new mobs"
  artifacts:
    - path: "src/main/java/thc/threat/ThreatManager.java"
      provides: "Threat data operations"
      min_lines: 30
    - path: "src/main/java/thc/THCAttachments.java"
      provides: "MOB_THREAT attachment registration"
      contains: "MOB_THREAT"
  key_links:
    - from: "ThreatManager.java"
      to: "THCAttachments.MOB_THREAT"
      via: "getAttachedOrCreate calls"
      pattern: "getAttachedOrCreate.*MOB_THREAT"
---

<objective>
Create the foundational threat data structure and storage system for per-mob threat tracking.

Purpose: Enable mobs to maintain a map of player UUIDs to threat values (as doubles). This is the data layer that all other threat mechanics will build upon.
Output: ThreatManager class with CRUD operations and Fabric attachment for threat storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/MOB_TARGETING_AI_RESEARCH.md

# Existing attachment pattern:
@src/main/java/thc/THCAttachments.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MOB_THREAT attachment to THCAttachments</name>
  <files>src/main/java/thc/THCAttachments.java</files>
  <action>
    Add a new attachment type for mob threat storage:

    ```java
    public static final AttachmentType<Map<UUID, Double>> MOB_THREAT = AttachmentRegistry.create(
        Identifier.fromNamespaceAndPath("thc", "mob_threat"),
        builder -> builder.initializer(HashMap::new)
    );
    ```

    Note: Do NOT make it persistent - threat should reset when mobs unload (per Out of Scope in REQUIREMENTS.md).

    Required imports: `java.util.Map`, `java.util.HashMap`, `java.util.UUID`
  </action>
  <verify>Build compiles without errors: `./gradlew build`</verify>
  <done>MOB_THREAT attachment registered in THCAttachments</done>
</task>

<task type="auto">
  <name>Task 2: Create ThreatManager utility class</name>
  <files>src/main/java/thc/threat/ThreatManager.java</files>
  <action>
    Create new package `thc.threat` and class `ThreatManager` with static methods:

    ```java
    package thc.threat;

    import net.minecraft.world.entity.Mob;
    import thc.THCAttachments;
    import java.util.Map;
    import java.util.UUID;

    public final class ThreatManager {
        private ThreatManager() {}

        /**
         * Add threat from a player to a mob.
         */
        public static void addThreat(Mob mob, UUID playerUuid, double amount) {
            if (amount <= 0) return;
            Map<UUID, Double> threats = mob.getAttachedOrCreate(THCAttachments.MOB_THREAT);
            double current = threats.getOrDefault(playerUuid, 0.0);
            threats.put(playerUuid, current + amount);
        }

        /**
         * Get current threat level for a player on a mob.
         */
        public static double getThreat(Mob mob, UUID playerUuid) {
            Map<UUID, Double> threats = mob.getAttached(THCAttachments.MOB_THREAT);
            if (threats == null) return 0.0;
            return threats.getOrDefault(playerUuid, 0.0);
        }

        /**
         * Set threat to a specific value.
         */
        public static void setThreat(Mob mob, UUID playerUuid, double amount) {
            Map<UUID, Double> threats = mob.getAttachedOrCreate(THCAttachments.MOB_THREAT);
            if (amount <= 0) {
                threats.remove(playerUuid);
            } else {
                threats.put(playerUuid, amount);
            }
        }

        /**
         * Get the threat map for a mob (for iteration).
         */
        public static Map<UUID, Double> getThreatMap(Mob mob) {
            return mob.getAttachedOrCreate(THCAttachments.MOB_THREAT);
        }

        /**
         * Check if mob has any threat registered.
         */
        public static boolean hasThreat(Mob mob) {
            Map<UUID, Double> threats = mob.getAttached(THCAttachments.MOB_THREAT);
            return threats != null && !threats.isEmpty();
        }
    }
    ```

    Keep it simple - just data operations. Decay and targeting logic will be in separate plans.
  </action>
  <verify>Build compiles: `./gradlew build`</verify>
  <done>ThreatManager class exists with addThreat, getThreat, setThreat, getThreatMap, hasThreat methods</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] MOB_THREAT attachment registered in THCAttachments
- [ ] ThreatManager class exists in thc.threat package
- [ ] ThreatManager has all required methods (add, get, set, getMap, has)
</verification>

<success_criteria>

- All tasks completed
- Build succeeds
- Foundation ready for threat propagation (Plan 02) and decay (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/15-threat-system/15-01-SUMMARY.md`
</output>
