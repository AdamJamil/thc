---
phase: 15-threat-system
plan: 04
type: execute
wave: 3
depends_on: ["15-01", "15-02", "15-03"]
files_modified:
  - src/main/java/thc/threat/ThreatTargetGoal.java
  - src/main/java/thc/threat/ThreatManager.java
  - src/main/java/thc/mixin/MonsterThreatGoalMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true
must_haves:
  truths:
    - "Mobs target highest-threat player when any player's threat >= 5"
    - "Mobs only switch targets on revenge strike OR strictly higher threat"
    - "Threat targeting has higher priority than default NearestAttackableTargetGoal"
    - "Revenge (getLastHurtByMob) allows immediate target switch"
  artifacts:
    - path: "src/main/java/thc/threat/ThreatTargetGoal.java"
      provides: "AI goal for threat-based targeting"
      min_lines: 60
    - path: "src/main/java/thc/mixin/MonsterThreatGoalMixin.java"
      provides: "Goal injection into Monster mobs"
      contains: "ThreatTargetGoal"
  key_links:
    - from: "ThreatTargetGoal.java"
      to: "ThreatManager"
      via: "threat lookup and decay"
      pattern: "ThreatManager\\.(getThreat|decayThreat|getHighestThreatTarget)"
    - from: "MonsterThreatGoalMixin.java"
      to: "ThreatTargetGoal"
      via: "goal injection in registerGoals"
      pattern: "targetSelector\\.addGoal.*ThreatTargetGoal"
---

<objective>
Implement threat-based mob targeting: mobs select targets based on threat levels with restricted switching.

Purpose: This is the behavior layer (THREAT-05, THREAT-06). Mobs use threat data to decide who to attack, with smart target-switching rules to create tactical gameplay.
Output: ThreatTargetGoal class and mixin to inject it into Monster mobs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/MOB_TARGETING_AI_RESEARCH.md

# Foundation from Plans 01-03:
@src/main/java/thc/threat/ThreatManager.java
@src/main/java/thc/THCAttachments.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getHighestThreatTarget method to ThreatManager</name>
  <files>src/main/java/thc/threat/ThreatManager.java</files>
  <action>
    Add method to find the highest-threat player that meets the minimum threshold:

    ```java
    import net.minecraft.server.level.ServerPlayer;
    import net.minecraft.world.entity.player.Player;
    import javax.annotation.Nullable;

    /**
     * Find the player with highest threat that meets minimum threshold.
     * Returns null if no player meets the threshold or is valid target.
     */
    @Nullable
    public static Player getHighestThreatTarget(Mob mob, double minThreat) {
        Map<UUID, Double> threats = mob.getAttached(THCAttachments.MOB_THREAT);
        if (threats == null || threats.isEmpty()) {
            return null;
        }

        Player highestPlayer = null;
        double highestThreat = minThreat;

        for (Map.Entry<UUID, Double> entry : threats.entrySet()) {
            if (entry.getValue() < minThreat) {
                continue;
            }

            Player player = mob.level().getPlayerByUUID(entry.getKey());
            if (player == null || !player.isAlive() || player.isSpectator()) {
                continue;
            }

            // Check if mob can actually attack this player
            if (!mob.canAttack(player)) {
                continue;
            }

            if (entry.getValue() > highestThreat || highestPlayer == null) {
                highestThreat = entry.getValue();
                highestPlayer = player;
            }
        }

        return highestPlayer;
    }
    ```

    Required imports: `import net.minecraft.world.entity.player.Player;`, `import javax.annotation.Nullable;`
  </action>
  <verify>Build compiles: `./gradlew build`</verify>
  <done>getHighestThreatTarget method added to ThreatManager</done>
</task>

<task type="auto">
  <name>Task 2: Create ThreatTargetGoal</name>
  <files>src/main/java/thc/threat/ThreatTargetGoal.java</files>
  <action>
    Create the AI goal that implements threat-based targeting:

    ```java
    package thc.threat;

    import net.minecraft.world.entity.LivingEntity;
    import net.minecraft.world.entity.Mob;
    import net.minecraft.world.entity.ai.goal.Goal;
    import net.minecraft.world.entity.ai.goal.target.TargetGoal;
    import net.minecraft.world.entity.player.Player;
    import javax.annotation.Nullable;
    import java.util.EnumSet;

    /**
     * AI goal that targets players based on threat levels.
     * Priority 0 (highest) to override default targeting.
     *
     * Targeting rules (THREAT-05, THREAT-06):
     * - Target highest-threat player when threat >= 5
     * - Only switch targets on:
     *   1. Revenge strike (mob was just hurt by different player)
     *   2. Another player gains strictly higher threat
     */
    public class ThreatTargetGoal extends TargetGoal {
        private static final double MIN_THREAT = 5.0;

        @Nullable
        private Player currentTarget;

        public ThreatTargetGoal(Mob mob) {
            super(mob, false); // checkVisibility = false (threat overrides LoS)
            this.setFlags(EnumSet.of(Goal.Flag.TARGET));
        }

        @Override
        public boolean canUse() {
            // Decay threat before checking (lazy decay)
            ThreatManager.decayThreat(this.mob);

            // Find highest threat target
            Player target = ThreatManager.getHighestThreatTarget(this.mob, MIN_THREAT);
            if (target != null) {
                this.currentTarget = target;
                return true;
            }
            return false;
        }

        @Override
        public void start() {
            this.mob.setTarget(this.currentTarget);
            super.start();
        }

        @Override
        public boolean canContinueToUse() {
            if (this.currentTarget == null || !this.currentTarget.isAlive() || this.currentTarget.isSpectator()) {
                return false;
            }

            // Decay threat
            ThreatManager.decayThreat(this.mob);

            // Check if current target still has sufficient threat
            double currentThreat = ThreatManager.getThreat(this.mob, this.currentTarget.getUUID());
            if (currentThreat < MIN_THREAT) {
                // Current target lost threat, find new target
                Player newTarget = ThreatManager.getHighestThreatTarget(this.mob, MIN_THREAT);
                if (newTarget != null) {
                    this.currentTarget = newTarget;
                    this.mob.setTarget(this.currentTarget);
                    return true;
                }
                return false;
            }

            // Check for revenge switch (THREAT-06: revenge allows immediate switch)
            LivingEntity revenge = this.mob.getLastHurtByMob();
            if (revenge instanceof Player revengePlayer && revengePlayer != this.currentTarget) {
                double revengeThreat = ThreatManager.getThreat(this.mob, revengePlayer.getUUID());
                if (revengeThreat >= MIN_THREAT) {
                    this.currentTarget = revengePlayer;
                    this.mob.setTarget(this.currentTarget);
                    return true;
                }
            }

            // Check for strictly higher threat (THREAT-06: only switch if strictly higher)
            Player highestTarget = ThreatManager.getHighestThreatTarget(this.mob, MIN_THREAT);
            if (highestTarget != null && highestTarget != this.currentTarget) {
                double highestThreat = ThreatManager.getThreat(this.mob, highestTarget.getUUID());
                if (highestThreat > currentThreat) { // Strictly greater
                    this.currentTarget = highestTarget;
                    this.mob.setTarget(this.currentTarget);
                }
            }

            return this.mob.canAttack(this.currentTarget);
        }

        @Override
        public void stop() {
            this.currentTarget = null;
            // Don't clear mob target - let lower priority goals handle it
            super.stop();
        }
    }
    ```

    Key design:
    - Priority 0 when added (highest, beats vanilla's priority 1-2)
    - Lazy decay on every check
    - Revenge allows immediate switch (THREAT-06)
    - Only switch on strictly higher threat (THREAT-06)
    - MIN_THREAT = 5 (THREAT-05)
  </action>
  <verify>Build compiles: `./gradlew build`</verify>
  <done>ThreatTargetGoal created with proper targeting and switching logic</done>
</task>

<task type="auto">
  <name>Task 3: Create MonsterThreatGoalMixin to inject goal</name>
  <files>src/main/java/thc/mixin/MonsterThreatGoalMixin.java</files>
  <action>
    Create mixin targeting Monster.class to inject ThreatTargetGoal:

    ```java
    package thc.mixin;

    import net.minecraft.world.entity.EntityType;
    import net.minecraft.world.entity.PathfinderMob;
    import net.minecraft.world.entity.monster.Monster;
    import net.minecraft.world.level.Level;
    import org.spongepowered.asm.mixin.Mixin;
    import org.spongepowered.asm.mixin.injection.At;
    import org.spongepowered.asm.mixin.injection.Inject;
    import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
    import thc.threat.ThreatTargetGoal;

    /**
     * Inject ThreatTargetGoal into all Monster mobs.
     * Monster is the base class for hostile mobs (zombie, skeleton, creeper, etc.)
     */
    @Mixin(Monster.class)
    public abstract class MonsterThreatGoalMixin extends PathfinderMob {

        protected MonsterThreatGoalMixin(EntityType<? extends PathfinderMob> type, Level level) {
            super(type, level);
        }

        @Inject(method = "registerGoals", at = @At("TAIL"))
        private void thc$addThreatTargetGoal(CallbackInfo ci) {
            // Priority 0 = highest priority, overrides default targeting (priority 1-2)
            this.targetSelector.addGoal(0, new ThreatTargetGoal(this));
        }
    }
    ```

    Note: Monster extends PathfinderMob extends Mob. We need to extend PathfinderMob for the super constructor.

    This covers all hostile mobs that extend Monster:
    - Zombie (and subtypes: Husk, Drowned, ZombieVillager)
    - Skeleton (and subtypes: Stray, WitherSkeleton)
    - Spider, CaveSpider
    - Creeper
    - Enderman
    - Slime, MagmaCube
    - Silverfish, Endermite
    - Phantom
    - Vindicator, Pillager, Evoker, Ravager
    - Witch
    - Guardian, ElderGuardian
    - Blaze, Ghast, Hoglin

    Does NOT cover Brain-based mobs (Warden, Piglin, Breeze) - those use different AI.
  </action>
  <verify>Build compiles: `./gradlew build`</verify>
  <done>MonsterThreatGoalMixin created to inject ThreatTargetGoal into all Monster mobs</done>
</task>

<task type="auto">
  <name>Task 4: Register MonsterThreatGoalMixin</name>
  <files>src/main/resources/thc.mixins.json</files>
  <action>
    Add "MonsterThreatGoalMixin" to the mixins array in thc.mixins.json.

    Add it alphabetically near other mixins.
  </action>
  <verify>Build and game launches without mixin errors: `./gradlew build`</verify>
  <done>MonsterThreatGoalMixin registered in mixin config</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] ThreatTargetGoal exists with proper targeting and switching logic
- [ ] MonsterThreatGoalMixin exists and is registered
- [ ] Goal injected at priority 0 (highest)
- [ ] All Monster mobs will use threat-based targeting
</verification>

<success_criteria>

- All tasks completed
- Build succeeds
- Threat targeting integrated into Monster mobs
- Phase 15 requirements THREAT-01 through THREAT-06 all addressed
</success_criteria>

<output>
After completion, create `.planning/phases/15-threat-system/15-04-SUMMARY.md`
</output>
