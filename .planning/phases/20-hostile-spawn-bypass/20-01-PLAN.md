---
phase: 20-hostile-spawn-bypass
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/mixin/MonsterSpawnLightMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "Hostile mobs spawn during server daytime (sky light has no effect)"
    - "Block light still prevents spawns (torches/lamps work as protection)"
    - "Base chunk spawn blocking still works (NaturalSpawnerMixin preserved)"
  artifacts:
    - path: "src/main/java/thc/mixin/MonsterSpawnLightMixin.java"
      provides: "Sky light bypass for monster spawn checks"
      contains: "isDarkEnoughToSpawn"
    - path: "src/main/resources/thc.mixins.json"
      provides: "Mixin registration"
      contains: "MonsterSpawnLightMixin"
  key_links:
    - from: "MonsterSpawnLightMixin"
      to: "Monster.isDarkEnoughToSpawn"
      via: "HEAD inject with cancellable"
      pattern: "@Inject.*isDarkEnoughToSpawn"
---

<objective>
Make hostile mobs spawn regardless of sky light level while preserving block light spawn prevention.

Purpose: In the Twilight Hardcore system, the world is perpetually hostile â€” mobs should spawn during daytime just as they do at night. However, players can still use torches and other light sources to protect areas.

Output: MonsterSpawnLightMixin that bypasses sky light checks but preserves block light checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing spawn blocking pattern (preserve this behavior)
@src/main/java/thc/mixin/NaturalSpawnerMixin.java

# Similar mixin pattern from Phase 19
@src/main/java/thc/mixin/MobSunBurnMixin.java

# Mixin registration file
@src/main/resources/thc.mixins.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MonsterSpawnLightMixin to bypass sky light checks</name>
  <files>src/main/java/thc/mixin/MonsterSpawnLightMixin.java</files>
  <action>
Create a mixin targeting `net.minecraft.world.entity.monster.Monster` that injects at HEAD of `isDarkEnoughToSpawn` with cancellable=true.

The vanilla method signature is:
```java
public static boolean isDarkEnoughToSpawn(
    ServerLevelAccessor serverLevelAccessor,
    BlockPos blockPos,
    RandomSource randomSource
)
```

The vanilla logic:
1. Checks SKY light - if too high, returns false (blocks spawn)
2. Checks BLOCK light against dimension's monsterSpawnBlockLightLimit
3. Checks overall brightness against dimension's monsterSpawnLightTest

**Implementation approach:**
Inject at HEAD and implement ONLY the block light check, bypassing sky light entirely:

```java
@Inject(
    method = "isDarkEnoughToSpawn",
    at = @At("HEAD"),
    cancellable = true
)
private static void thc$bypassSkyLightCheck(
        ServerLevelAccessor level,
        BlockPos pos,
        RandomSource random,
        CallbackInfoReturnable<Boolean> cir) {

    // Skip sky light check entirely - mobs can spawn in daylight

    // Preserve block light check - torches still protect areas
    DimensionType dimensionType = level.dimensionType();
    int blockLightLimit = dimensionType.monsterSpawnBlockLightLimit();
    if (blockLightLimit < 15 && level.getBrightness(LightLayer.BLOCK, pos) > blockLightLimit) {
        cir.setReturnValue(false);
        return;
    }

    // Preserve the final brightness test (uses combined light in some cases)
    int brightness = level.getLevel().isThundering()
        ? level.getMaxLocalRawBrightness(pos, 10)
        : level.getMaxLocalRawBrightness(pos);

    // Only check block-based brightness contribution
    // The monsterSpawnLightTest is dimension-specific randomized threshold
    cir.setReturnValue(brightness <= dimensionType.monsterSpawnLightTest().sample(random));
}
```

**Required imports:**
- net.minecraft.world.entity.monster.Monster
- net.minecraft.core.BlockPos
- net.minecraft.util.RandomSource
- net.minecraft.world.level.ServerLevelAccessor
- net.minecraft.world.level.LightLayer
- net.minecraft.world.level.dimension.DimensionType
- org.spongepowered.asm.mixin.Mixin
- org.spongepowered.asm.mixin.injection.At
- org.spongepowered.asm.mixin.injection.Inject
- org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable

**What NOT to do:**
- Don't remove the block light check (SPAWN-02 requires block light to still affect spawns)
- Don't modify NaturalSpawnerMixin (base chunk blocking must remain separate)
  </action>
  <verify>File exists with @Mixin(Monster.class) and isDarkEnoughToSpawn injection. Build with `./gradlew build` succeeds.</verify>
  <done>MonsterSpawnLightMixin created with sky light bypass and block light preservation</done>
</task>

<task type="auto">
  <name>Task 2: Register MonsterSpawnLightMixin in mixin config</name>
  <files>src/main/resources/thc.mixins.json</files>
  <action>
Add "MonsterSpawnLightMixin" to the mixins array in thc.mixins.json.

Follow the existing pattern - add it alphabetically or at the end of the mixins list.
  </action>
  <verify>`./gradlew build` succeeds with no mixin errors</verify>
  <done>MonsterSpawnLightMixin registered and build passes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] MonsterSpawnLightMixin.java exists with correct injection target
- [ ] thc.mixins.json includes MonsterSpawnLightMixin
- [ ] No changes to NaturalSpawnerMixin (base blocking preserved)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SPAWN-01 implemented (hostile mobs can spawn regardless of sky light)
- SPAWN-02 preserved (block light still affects spawn density)
- No regressions to base chunk spawn blocking
</success_criteria>

<output>
After completion, create `.planning/phases/20-hostile-spawn-bypass/20-01-SUMMARY.md`
</output>
