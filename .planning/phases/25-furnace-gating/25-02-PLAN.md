---
phase: 25-furnace-gating
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/mixin/StructureTemplateMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "Furnaces do not appear in newly generated village structures"
    - "Blast furnaces do not appear in newly generated village structures"
    - "Other village blocks remain unaffected"
  artifacts:
    - path: "src/main/java/thc/mixin/StructureTemplateMixin.java"
      provides: "Structure block filtering for furnaces"
      contains: "FURNACE"
      min_lines: 20
    - path: "src/main/resources/thc.mixins.json"
      provides: "Mixin registration"
      contains: "StructureTemplateMixin"
  key_links:
    - from: "StructureTemplateMixin.java"
      to: "StructureTemplate.placeInWorld"
      via: "@Inject at HEAD"
      pattern: "placeInWorld"
---

<objective>
Prevent furnaces and blast furnaces from spawning in village structures.

Purpose: Complete the furnace gating system by ensuring players cannot obtain furnaces from villages. Combined with recipe gating (Plan 01), this forces Nether access for smelting capability.

Output: Mixin that filters furnace blocks from structure generation, preventing them from appearing in any structure (primarily villages).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Relevant source files:
@src/main/java/thc/mixin/NaturalSpawnerMixin.java (example HEAD inject pattern)
@src/main/java/thc/mixin/RecipeManagerMixin.java (example filtering with Set)
@src/main/resources/thc.mixins.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StructureTemplateMixin to filter furnaces from structure placement</name>
  <files>src/main/java/thc/mixin/StructureTemplateMixin.java</files>
  <action>
    Create a mixin that intercepts structure template block placement and removes furnaces.

    **Approach:** Use @ModifyVariable to modify the block list before placement, or use @Redirect on the actual setBlock call within placeInWorld.

    **Target method:** `StructureTemplate.placeInWorld` - this is where structure templates get placed into the world.

    **Implementation strategy:**
    1. Define a Set of blocks to filter: Blocks.FURNACE, Blocks.BLAST_FURNACE
    2. Intercept the placement loop where blocks are set
    3. Skip placement if block is in the filter set

    **Key insight from research:** The method processes a list of StructureBlockInfo and calls level.setBlock() for each. Use @Redirect on the setBlock call to conditionally skip furnaces.

    ```java
    @Mixin(StructureTemplate.class)
    public class StructureTemplateMixin {
        @Unique
        private static final Set<Block> FILTERED_STRUCTURE_BLOCKS = Set.of(
            Blocks.FURNACE,
            Blocks.BLAST_FURNACE
        );

        @Redirect(
            method = "placeInWorld",
            at = @At(
                value = "INVOKE",
                target = "Lnet/minecraft/world/level/ServerLevelAccessor;setBlock(Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/level/block/state/BlockState;I)Z"
            )
        )
        private boolean thc$filterFurnaceBlocks(
                ServerLevelAccessor level,
                BlockPos pos,
                BlockState state,
                int flags) {
            if (FILTERED_STRUCTURE_BLOCKS.contains(state.getBlock())) {
                return true; // Pretend we placed it, but actually skip
            }
            return level.setBlock(pos, state, flags);
        }
    }
    ```

    **Important:** The exact method signature and target may need adjustment based on MC 1.21.11 mappings. Check yarn/mojmap mappings if build fails.

    **Alternative approach if @Redirect doesn't work:** Use @Inject with @Local to access the BlockState being placed and cancel specific placements.

    Add necessary imports:
    - net.minecraft.world.level.levelgen.structure.StructureTemplate
    - net.minecraft.world.level.ServerLevelAccessor
    - net.minecraft.world.level.block.state.BlockState
    - net.minecraft.world.level.block.Block
    - net.minecraft.world.level.block.Blocks
    - net.minecraft.core.BlockPos
  </action>
  <verify>Build succeeds: `./gradlew build` passes without errors</verify>
  <done>StructureTemplateMixin.java exists with furnace/blast furnace filtering logic</done>
</task>

<task type="auto">
  <name>Task 2: Register StructureTemplateMixin</name>
  <files>src/main/resources/thc.mixins.json</files>
  <action>
    Add "StructureTemplateMixin" to the mixins array in thc.mixins.json.

    The mixin should be in the main mixins array (not client array) since structure generation happens server-side.

    Existing format to follow:
    ```json
    "mixins": [
      "ExistingMixin1",
      "ExistingMixin2",
      "StructureTemplateMixin"  // Add this
    ]
    ```
  </action>
  <verify>thc.mixins.json contains "StructureTemplateMixin" in mixins array</verify>
  <done>StructureTemplateMixin registered in thc.mixins.json</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew build` succeeds without errors
- [ ] StructureTemplateMixin.java exists with @Redirect or @Inject pattern
- [ ] FILTERED_STRUCTURE_BLOCKS contains Blocks.FURNACE and Blocks.BLAST_FURNACE
- [ ] StructureTemplateMixin registered in thc.mixins.json
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Mixin compiles and targets correct method
- Furnace and blast furnace blocks filtered from structure placement
</success_criteria>

<output>
After completion, create `.planning/phases/25-furnace-gating/25-02-SUMMARY.md`
</output>
