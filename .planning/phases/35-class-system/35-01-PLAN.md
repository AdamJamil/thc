---
phase: 35-class-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/THCAttachments.java
  - src/main/java/thc/playerclass/PlayerClass.java
  - src/main/java/thc/playerclass/ClassManager.java
  - src/main/java/thc/playerclass/SelectClassCommand.java
  - src/main/kotlin/thc/THC.kt
autonomous: true

must_haves:
  truths:
    - "/selectClass <class> command exists and is registered"
    - "Command only works when player is in a base chunk"
    - "Command fails with actionbar message if player already has a class"
    - "Command shows title + chat message on success"
    - "Class selection modifies player max health based on class"
    - "Class persists across sessions"
  artifacts:
    - path: "src/main/java/thc/THCAttachments.java"
      provides: "PLAYER_CLASS attachment"
      contains: "PLAYER_CLASS"
    - path: "src/main/java/thc/playerclass/PlayerClass.java"
      provides: "PlayerClass enum with multipliers"
      exports: ["PlayerClass"]
    - path: "src/main/java/thc/playerclass/ClassManager.java"
      provides: "Static utility for class CRUD"
      exports: ["getClass", "setClass"]
    - path: "src/main/java/thc/playerclass/SelectClassCommand.java"
      provides: "Command registration"
      exports: ["register"]
  key_links:
    - from: "SelectClassCommand.java"
      to: "ClaimManager.isInBase"
      via: "base chunk check"
      pattern: "ClaimManager\\.INSTANCE\\.isInBase"
    - from: "SelectClassCommand.java"
      to: "ClassManager"
      via: "class CRUD"
      pattern: "ClassManager\\.(getClass|setClass)"
    - from: "ClassManager.java"
      to: "THCAttachments.PLAYER_CLASS"
      via: "attachment access"
      pattern: "THCAttachments\\.PLAYER_CLASS"
---

<objective>
Create the class system foundation: persistent attachment storage, enum with stat multipliers, and the /selectClass command with base chunk restriction.

Purpose: Enable permanent role selection that persists across sessions and provides the foundation for damage/health modifiers.
Output: Working /selectClass command, PlayerClass enum, ClassManager utility, PLAYER_CLASS attachment.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-class-system/35-CONTEXT.md
@.planning/phases/35-class-system/35-RESEARCH.md

# Existing patterns to follow
@src/main/java/thc/THCAttachments.java
@src/main/java/thc/mixin/ServerPlayerMixin.java
@src/main/java/thc/access/ServerPlayerHealthAccess.java
@src/main/kotlin/thc/claim/ClaimManager.kt
@src/main/kotlin/thc/THC.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create class data structures and attachment</name>
  <files>
    src/main/java/thc/THCAttachments.java
    src/main/java/thc/playerclass/PlayerClass.java
    src/main/java/thc/playerclass/ClassManager.java
  </files>
  <action>
1. Add PLAYER_CLASS attachment to THCAttachments.java:
   - Type: AttachmentType<String>
   - Identifier: "thc:player_class"
   - initializer: () -> null (no class by default)
   - persistent(Codec.STRING)
   - copyOnDeath()

2. Create src/main/java/thc/playerclass/PlayerClass.java enum:
   ```java
   public enum PlayerClass {
       TANK(2.0, 2.5, 1.0),      // +1 heart, x2.5 melee, x1 ranged
       MELEE(1.0, 4.0, 1.0),     // +0.5 hearts, x4 melee, x1 ranged
       RANGED(0.0, 1.0, 5.0),    // no health change, x1 melee, x5 ranged
       SUPPORT(0.0, 1.0, 3.0);   // no health change, x1 melee, x3 ranged

       private final double healthBonus;  // In HP (2 HP = 1 heart)
       private final double meleeMultiplier;
       private final double rangedMultiplier;

       // Constructor, getters
       // fromString(String) method with case-insensitive lookup
   }
   ```
   Note: healthBonus is in HP (Tank=2.0 HP=1 heart, Melee=1.0 HP=0.5 hearts)

3. Create src/main/java/thc/playerclass/ClassManager.java (static utility pattern like ThreatManager):
   ```java
   public final class ClassManager {
       public static PlayerClass getClass(ServerPlayer player) {
           String className = player.getAttached(THCAttachments.PLAYER_CLASS);
           if (className == null) return null;
           return PlayerClass.fromString(className);
       }

       public static boolean hasClass(ServerPlayer player) {
           return getClass(player) != null;
       }

       public static boolean setClass(ServerPlayer player, PlayerClass playerClass) {
           if (hasClass(player)) return false; // Already has class - permanent
           player.setAttached(THCAttachments.PLAYER_CLASS, playerClass.name());
           applyHealthModifier(player, playerClass);
           return true;
       }

       private static void applyHealthModifier(ServerPlayer player, PlayerClass playerClass) {
           // Use existing ServerPlayerHealthAccess interface
           double baseHealth = 8.0; // THC default (4 hearts)
           double newHealth = baseHealth + playerClass.getHealthBonus();
           ((ServerPlayerHealthAccess) player).thc$setMaxHealth(newHealth);
       }
   }
   ```
  </action>
  <verify>
    - Compile: `cd /mnt/c/home/code/thc && ./gradlew compileJava`
    - Verify PlayerClass.fromString("tank") returns TANK
    - Verify PlayerClass.fromString("TANK") returns TANK (case insensitive)
  </verify>
  <done>
    - PLAYER_CLASS attachment exists with persistence and copyOnDeath
    - PlayerClass enum has all 4 classes with correct stat values
    - ClassManager provides getClass, hasClass, setClass methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /selectClass command with feedback</name>
  <files>
    src/main/java/thc/playerclass/SelectClassCommand.java
    src/main/kotlin/thc/THC.kt
  </files>
  <action>
1. Create src/main/java/thc/playerclass/SelectClassCommand.java:
   ```java
   public final class SelectClassCommand {
       public static void register() {
           CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
               dispatcher.register(Commands.literal("selectClass")
                   .then(Commands.argument("class", StringArgumentType.string())
                       .suggests((context, builder) -> {
                           builder.suggest("tank");
                           builder.suggest("melee");
                           builder.suggest("ranged");
                           builder.suggest("support");
                           return builder.buildFuture();
                       })
                       .executes(SelectClassCommand::execute)));
           });
       }

       private static int execute(CommandContext<CommandSourceStack> context) {
           // Get player (command requires player source)
           Entity entity = context.getSource().getEntity();
           if (!(entity instanceof ServerPlayer player)) {
               return 0;
           }

           String className = StringArgumentType.getString(context, "class");

           // Validate class name
           PlayerClass playerClass = PlayerClass.fromString(className);
           if (playerClass == null) {
               // Actionbar: invalid class
               player.displayClientMessage(
                   Component.literal("Invalid class: " + className).withStyle(ChatFormatting.RED),
                   true  // actionbar
               );
               return 0;
           }

           // Check if already has class
           if (ClassManager.hasClass(player)) {
               // Actionbar: already has class
               player.displayClientMessage(
                   Component.literal("You already have a class!").withStyle(ChatFormatting.RED),
                   true
               );
               return 0;
           }

           // Check if in base
           MinecraftServer server = player.getServer();
           if (server == null || !ClaimManager.INSTANCE.isInBase(server, player.blockPosition())) {
               // Actionbar: not in base
               player.displayClientMessage(
                   Component.literal("You must be in a base to select a class!").withStyle(ChatFormatting.RED),
                   true
               );
               return 0;
           }

           // Set class
           ClassManager.setClass(player, playerClass);

           // Success: Title + chat
           player.sendSystemMessage(
               Component.literal("You are now a " + playerClass.name().toLowerCase() + "!")
                   .withStyle(ChatFormatting.GREEN)
           );

           // Title announcement
           player.connection.send(new ClientboundSetTitleTextPacket(
               Component.literal(playerClass.name()).withStyle(ChatFormatting.GOLD)
           ));
           player.connection.send(new ClientboundSetSubtitleTextPacket(
               Component.literal("Class Selected").withStyle(ChatFormatting.YELLOW)
           ));
           player.connection.send(new ClientboundSetTitlesAnimationPacket(10, 60, 10)); // 0.5s fade in, 3s stay, 0.5s fade out

           return 1;
       }
   }
   ```

2. Register command in THC.kt onInitialize():
   - Add import: `import thc.playerclass.SelectClassCommand`
   - Add call: `SelectClassCommand.register()` after other registrations
  </action>
  <verify>
    - Compile: `cd /mnt/c/home/code/thc && ./gradlew compileJava compileKotlin`
    - Smoke test: `cd /mnt/c/home/code/thc && ./gradlew runServer -Dthc.smokeTest=true`
  </verify>
  <done>
    - /selectClass command registered with tab completion for all 4 classes
    - Command shows actionbar error when: invalid class, already has class, not in base
    - Command shows title + chat message on successful class selection
    - Class persists via attachment (copyOnDeath + persistent)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compile check:** `./gradlew build` completes without errors
2. **Smoke test:** `./gradlew runServer -Dthc.smokeTest=true` passes (100 ticks)
3. **Class attachment:** PLAYER_CLASS attachment registered with persistence

Code verification (grep):
- `grep -r "PLAYER_CLASS" src/main/java/thc/` shows attachment in THCAttachments
- `grep -r "selectClass" src/main/java/thc/` shows command registration
- `grep -r "isInBase" src/main/java/thc/playerclass/` shows base chunk check
</verification>

<success_criteria>
- /selectClass command exists and provides tab completion
- Command validates: class name, already has class, in base chunk
- Feedback: actionbar for errors, title + chat for success
- ClassManager provides getClass/hasClass/setClass utilities
- PlayerClass enum contains all 4 classes with correct multipliers
- Class selection modifies max health via existing ServerPlayerHealthAccess
- PLAYER_CLASS attachment persists across sessions (persistent + copyOnDeath)
</success_criteria>

<output>
After completion, create `.planning/phases/35-class-system/35-01-SUMMARY.md`
</output>
