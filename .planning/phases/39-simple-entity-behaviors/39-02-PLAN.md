---
phase: 39-simple-entity-behaviors
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/mixin/PhantomSpawnerMixin.java
  - src/main/java/thc/mixin/PatrolSpawnerMixin.java
  - src/main/java/thc/mixin/CarvedPumpkinBlockMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "Player can go 3+ in-game days without sleeping - zero phantom spawns"
    - "At stage 1, extended AFK yields zero illager patrols"
    - "Advance to stage 2, patrols resume spawning normally"
    - "Building iron golem pattern (pumpkin + iron blocks) creates no golem"
  artifacts:
    - path: "src/main/java/thc/mixin/PhantomSpawnerMixin.java"
      provides: "HEAD cancellation of PhantomSpawner.tick returning 0"
      contains: "@Inject.*HEAD.*cancellable"
    - path: "src/main/java/thc/mixin/PatrolSpawnerMixin.java"
      provides: "Conditional HEAD cancellation when stage < 2"
      contains: "StageManager.getCurrentStage"
    - path: "src/main/java/thc/mixin/CarvedPumpkinBlockMixin.java"
      provides: "Iron golem pattern check interception"
      contains: "trySpawnGolem"
  key_links:
    - from: "PatrolSpawnerMixin.java"
      to: "thc.stage.StageManager"
      via: "getCurrentStage call"
      pattern: "StageManager\\.getCurrentStage"
    - from: "thc.mixins.json"
      to: "PhantomSpawnerMixin"
      via: "mixin registration"
      pattern: "PhantomSpawnerMixin"
---

<objective>
Implement spawner HEAD cancellations for phantom and patrol control, plus iron golem summon prevention.

Purpose:
- Phantoms are annoying insomnia punishment removed entirely from THC
- Illager patrols are gated to stage 2+ to give players early-game breathing room
- Player-summoned iron golems bypass intended difficulty by trivializing mob defense

Output: Three Java mixins with HEAD cancellation patterns, registered in thc.mixins.json
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-simple-entity-behaviors/39-RESEARCH.md
@src/main/java/thc/mixin/MonsterSpawnLightMixin.java
@src/main/java/thc/stage/StageManager.java
@src/main/kotlin/thc/stage/StageData.kt
@src/main/resources/thc.mixins.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PhantomSpawnerMixin for phantom spawn removal</name>
  <files>src/main/java/thc/mixin/PhantomSpawnerMixin.java</files>
  <action>
Create PhantomSpawnerMixin.java to completely disable natural phantom spawning (FR-14).

Implementation:

```java
package thc.mixin;

import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.levelgen.PhantomSpawner;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * Disable natural phantom spawning from insomnia.
 *
 * Part of THC difficulty design - phantoms removed entirely from natural
 * spawning. Players can still encounter phantoms via spawn eggs or commands.
 *
 * PhantomSpawner is a custom spawner (not biome-based) that triggers based
 * on player insomnia statistics. HEAD cancellation returning 0 prevents all
 * spawn attempts while leaving insomnia stat unchanged.
 */
@Mixin(PhantomSpawner.class)
public abstract class PhantomSpawnerMixin {

    /**
     * Block all phantom natural spawn attempts.
     *
     * PhantomSpawner.tick returns int count of spawned phantoms.
     * Returning 0 indicates no spawns occurred this tick.
     */
    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void thc$disablePhantomSpawns(
            ServerLevel level,
            boolean spawnEnemies,
            boolean spawnFriendlies,
            CallbackInfoReturnable<Integer> cir) {
        cir.setReturnValue(0);
    }
}
```

The signature `tick(ServerLevel, boolean, boolean)` matches Minecraft 1.21.11 PhantomSpawner.
  </action>
  <verify>File exists: `ls src/main/java/thc/mixin/PhantomSpawnerMixin.java`</verify>
  <done>PhantomSpawnerMixin.java exists with HEAD cancellation returning 0</done>
</task>

<task type="auto">
  <name>Task 2: Create PatrolSpawnerMixin for stage-gated patrol control</name>
  <files>src/main/java/thc/mixin/PatrolSpawnerMixin.java</files>
  <action>
Create PatrolSpawnerMixin.java to gate illager patrols to stage 2+ (FR-15).

Implementation:

```java
package thc.mixin;

import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.levelgen.PatrolSpawner;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
import thc.stage.StageManager;

/**
 * Gate illager patrol spawning to stage 2+.
 *
 * Part of THC stage progression - illager patrols don't appear until server
 * reaches stage 2. This gives players time to establish defenses before
 * facing organized illager groups.
 *
 * Server starts at stage 1, so patrols are blocked initially.
 * When stage advances to 2 (via evoker kill), patrols resume.
 */
@Mixin(PatrolSpawner.class)
public abstract class PatrolSpawnerMixin {

    /**
     * Block patrol spawns if server stage is below 2.
     *
     * PatrolSpawner.tick returns int count of spawned patrols.
     * Returning 0 blocks spawn for this tick.
     */
    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void thc$gatePatrolsToStage2(
            ServerLevel level,
            boolean spawnEnemies,
            boolean spawnFriendlies,
            CallbackInfoReturnable<Integer> cir) {

        int currentStage = StageManager.getCurrentStage(level.getServer());
        if (currentStage < 2) {
            cir.setReturnValue(0);
        }
        // If stage >= 2, allow vanilla patrol spawn logic to proceed
    }
}
```

Note: Server starts at stage 1 (from StageData.kt default), so `currentStage < 2` blocks patrols at game start.
  </action>
  <verify>File exists: `ls src/main/java/thc/mixin/PatrolSpawnerMixin.java`</verify>
  <done>PatrolSpawnerMixin.java exists with stage-gated HEAD cancellation</done>
</task>

<task type="auto">
  <name>Task 3: Create CarvedPumpkinBlockMixin for iron golem prevention</name>
  <files>src/main/java/thc/mixin/CarvedPumpkinBlockMixin.java</files>
  <action>
Create CarvedPumpkinBlockMixin.java to prevent player-summoned iron golems (FR-17).

The key insight from research: CarvedPumpkinBlock.onPlace calls trySpawnGolem which checks for both iron golem and snow golem patterns. We need to intercept trySpawnGolem specifically for iron golems, not block all pumpkin placement.

Looking at Minecraft source, trySpawnGolem has checks for:
1. Iron golem pattern (T-shape iron blocks)
2. Snow golem pattern (vertical snow blocks)

Best approach: @Redirect on the iron golem spawn call, or HEAD-cancel trySpawnGolem with manual snow golem handling.

Simpler approach for THC: Intercept at checkSpawn (internal pattern check) and return without spawning iron golem.

Implementation using trySpawnGolem interception:

```java
package thc.mixin;

import net.minecraft.core.BlockPos;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.CarvedPumpkinBlock;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.pattern.BlockInWorld;
import net.minecraft.world.level.block.state.pattern.BlockPattern;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * Prevent player-summoned iron golems via pumpkin pattern.
 *
 * Part of THC difficulty - players cannot create iron golems using the
 * traditional pumpkin + iron block pattern. This forces reliance on
 * village-spawned golems for iron golem presence.
 *
 * Note: Villager-summoned golems still work (different code path via
 * Villager.spawnGolem). Existing golems in world are unaffected.
 * Snow golems can still be built (different pattern).
 */
@Mixin(CarvedPumpkinBlock.class)
public abstract class CarvedPumpkinBlockMixin {

    @Shadow
    private static BlockPattern ironGolemFull;

    /**
     * Intercept golem spawn attempt and block iron golem creation.
     *
     * The trySpawnGolem method is called from onPlace after the pumpkin
     * is placed. It checks for both iron golem and snow golem patterns.
     *
     * We inject at HEAD, check for iron golem pattern ourselves, and if
     * found, cancel without spawning. Snow golem path proceeds normally.
     */
    @Inject(method = "trySpawnGolem", at = @At("HEAD"), cancellable = true)
    private void thc$preventIronGolemSummon(
            Level level,
            BlockPos pos,
            CallbackInfo ci) {

        // Check if iron golem pattern is present
        // If so, cancel (don't spawn) but allow block to remain placed
        // Snow golem will be checked by vanilla if we don't cancel

        if (!level.isClientSide) {
            BlockPattern.BlockPatternMatch match = getOrCreateIronGolemFull()
                .find(level, pos);
            if (match != null) {
                // Iron golem pattern detected - cancel to prevent spawn
                // The pumpkin stays placed, just no golem spawns
                ci.cancel();
            }
        }
        // If no iron golem pattern, let vanilla continue for snow golem check
    }

    @Shadow
    private static BlockPattern getOrCreateIronGolemFull() {
        throw new AssertionError();
    }
}
```

Note: This approach checks for iron golem pattern at HEAD. If found, we cancel (preventing spawn). If not found, vanilla continues and may spawn snow golem. The pumpkin block remains placed either way since we're in trySpawnGolem, not onPlace.
  </action>
  <verify>File exists: `ls src/main/java/thc/mixin/CarvedPumpkinBlockMixin.java`</verify>
  <done>CarvedPumpkinBlockMixin.java exists with iron golem pattern interception</done>
</task>

<task type="auto">
  <name>Task 4: Register mixins in thc.mixins.json and verify build</name>
  <files>src/main/resources/thc.mixins.json</files>
  <action>
Add the three new mixins to thc.mixins.json:

1. Add to the "mixins" array (alphabetically or at end):
   - "PhantomSpawnerMixin"
   - "PatrolSpawnerMixin"
   - "CarvedPumpkinBlockMixin"

Then verify build succeeds: `./gradlew build`

If build fails with mixin errors, check:
- Method signature matches Minecraft 1.21.11 (tick takes ServerLevel, boolean, boolean)
- trySpawnGolem method name is correct
- getOrCreateIronGolemFull shadow is correct
  </action>
  <verify>Build succeeds: `./gradlew build`</verify>
  <done>thc.mixins.json includes all three new mixins and build passes</done>
</task>

</tasks>

<verification>
1. Build compiles without errors: `./gradlew build`
2. Code review:
   - PhantomSpawnerMixin.java exists with HEAD cancellation returning 0
   - PatrolSpawnerMixin.java exists with stage < 2 check using StageManager
   - CarvedPumpkinBlockMixin.java exists with iron golem pattern interception
   - thc.mixins.json includes all three mixins
3. Pattern consistency:
   - Uses @Inject(method, at = @At("HEAD"), cancellable = true) pattern
   - Method signatures match Minecraft 1.21.11
   - THC naming convention (thc$methodName)
</verification>

<success_criteria>
- Build passes with no compilation errors
- FR-14: PhantomSpawner.tick HEAD cancellation implemented
- FR-15: PatrolSpawner.tick stage-gated cancellation implemented
- FR-17: CarvedPumpkinBlock iron golem prevention implemented
- All three mixins registered in thc.mixins.json
</success_criteria>

<output>
After completion, create `.planning/phases/39-simple-entity-behaviors/39-02-SUMMARY.md`
</output>
