---
phase: 41-nbt-spawn-origin-tagging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/THCAttachments.java
  - src/main/java/thc/mixin/MobFinalizeSpawnMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "Surface-spawned mob has spawnSystem.region = OW_SURFACE in NBT"
    - "Upper cave mob (Y >= 0, below heightmap) has spawnSystem.region = OW_UPPER_CAVE"
    - "Lower cave mob (Y < 0) has spawnSystem.region = OW_LOWER_CAVE"
    - "NATURAL + MONSTER spawns have spawnSystem.counted = true"
    - "Structure spawner mobs have no spawn tags"
  artifacts:
    - path: "src/main/java/thc/THCAttachments.java"
      provides: "SPAWN_REGION and SPAWN_COUNTED attachment definitions"
      contains: "SPAWN_REGION"
    - path: "src/main/java/thc/mixin/MobFinalizeSpawnMixin.java"
      provides: "Spawn-time tagging logic with region detection"
      min_lines: 40
  key_links:
    - from: "MobFinalizeSpawnMixin.java"
      to: "THCAttachments.SPAWN_REGION"
      via: "setAttached call"
      pattern: "setAttached.*SPAWN_REGION"
    - from: "MobFinalizeSpawnMixin.java"
      to: "Heightmap.Type.MOTION_BLOCKING"
      via: "getTopY call for region detection"
      pattern: "getTopY.*MOTION_BLOCKING"
---

<objective>
Add NBT spawn origin tagging infrastructure for regional monster cap counting.

Purpose: Phase 42 (regional spawns) and Phase 43 (cap partitioning) need to know where each mob spawned. This phase adds two persistent attachments to all naturally-spawned mobs: SPAWN_REGION (which Overworld region) and SPAWN_COUNTED (whether it counts toward caps).

Output: Two new attachments in THCAttachments.java and a MobFinalizeSpawnMixin that tags mobs at spawn time based on position.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-nbt-spawn-origin-tagging/41-CONTEXT.md
@.planning/phases/41-nbt-spawn-origin-tagging/41-RESEARCH.md

# Existing attachment patterns
@src/main/java/thc/THCAttachments.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spawn origin attachments</name>
  <files>src/main/java/thc/THCAttachments.java</files>
  <action>
Add two new persistent attachments to THCAttachments.java:

1. SPAWN_REGION (String, persistent):
   - Identifier: "thc:spawn_region"
   - Initializer: null (no default - absence means "not tagged")
   - Persistent via Codec.STRING
   - No copyOnDeath (mob-only, not player)

2. SPAWN_COUNTED (Boolean, persistent):
   - Identifier: "thc:spawn_counted"
   - Initializer: false
   - Persistent via Codec.BOOL
   - No copyOnDeath (mob-only, not player)

Follow the existing PLAYER_CLASS pattern for String attachments and BELL_ACTIVATED pattern for Boolean attachments. These are simple attachment registrations - no complex codecs needed.

Note: Research suggests byte encoding for efficiency, but CONTEXT.md gives Claude discretion. String encoding is simpler for debugging (NBT viewer shows "OW_SURFACE" not "0") and the storage difference is negligible (~12 bytes per entity). Start simple.
  </action>
  <verify>
Build compiles: `./gradlew build`
Attachments exist: grep for SPAWN_REGION and SPAWN_COUNTED in THCAttachments.java
  </verify>
  <done>
THCAttachments.java contains SPAWN_REGION (String) and SPAWN_COUNTED (Boolean) attachment definitions with persistent codecs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MobFinalizeSpawnMixin for spawn tagging</name>
  <files>
src/main/java/thc/mixin/MobFinalizeSpawnMixin.java
src/main/resources/thc.mixins.json
  </files>
  <action>
Create MobFinalizeSpawnMixin.java that injects at TAIL of Mob.finalizeSpawn to tag mobs with their spawn origin.

Mixin structure:
```java
@Mixin(Mob.class)
public class MobFinalizeSpawnMixin {
    @Inject(method = "finalizeSpawn", at = @At("TAIL"))
    private void thc$tagSpawnOrigin(
            ServerLevelAccessor level, DifficultyInstance difficulty,
            EntitySpawnReason reason, SpawnGroupData groupData,
            CallbackInfoReturnable<SpawnGroupData> cir) {
        // Implementation
    }
}
```

Implementation logic (in order):

1. Filter spawn reason - return early if not NATURAL and not CHUNK_GENERATION:
   ```java
   if (reason != EntitySpawnReason.NATURAL && reason != EntitySpawnReason.CHUNK_GENERATION) {
       return;
   }
   ```

2. Filter dimension - return early if not Overworld:
   ```java
   ServerLevel serverLevel = (ServerLevel) level.getLevel();
   if (serverLevel.dimension() != Level.OVERWORLD) {
       return;
   }
   ```

3. Detect region using heightmap comparison:
   ```java
   @Unique
   private static String detectRegion(ServerLevel level, BlockPos pos) {
       int y = pos.getY();

       // Lower cave: below Y=0 (sea level)
       if (y < 0) {
           return "OW_LOWER_CAVE";
       }

       // Surface: Y >= heightmap at X/Z
       int surfaceY = level.getTopY(Heightmap.Type.MOTION_BLOCKING, pos.getX(), pos.getZ());
       if (y >= surfaceY) {
           return "OW_SURFACE";
       }

       // Upper cave: Y >= 0 but below heightmap
       return "OW_UPPER_CAVE";
   }
   ```

4. Set SPAWN_REGION attachment:
   ```java
   Mob self = (Mob) (Object) this;
   String region = detectRegion(serverLevel, self.blockPosition());
   self.setAttached(THCAttachments.SPAWN_REGION, region);
   ```

5. Set SPAWN_COUNTED attachment (only true for MONSTER category):
   ```java
   boolean isMonster = self.getType().getCategory() == MobCategory.MONSTER;
   self.setAttached(THCAttachments.SPAWN_COUNTED, isMonster);
   ```

Required imports:
- net.minecraft.core.BlockPos
- net.minecraft.server.level.ServerLevel
- net.minecraft.world.Difficulty (for DifficultyInstance)
- net.minecraft.world.DifficultyInstance
- net.minecraft.world.entity.EntitySpawnReason
- net.minecraft.world.entity.Mob
- net.minecraft.world.entity.MobCategory
- net.minecraft.world.entity.SpawnGroupData
- net.minecraft.world.level.Level
- net.minecraft.world.level.ServerLevelAccessor
- net.minecraft.world.level.levelgen.Heightmap
- org.spongepowered.asm.mixin.Mixin
- org.spongepowered.asm.mixin.Unique
- org.spongepowered.asm.mixin.injection.At
- org.spongepowered.asm.mixin.injection.Inject
- org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable
- thc.THCAttachments

After creating the mixin, add "MobFinalizeSpawnMixin" to thc.mixins.json in the mixins array.
  </action>
  <verify>
Build compiles: `./gradlew build`
Mixin registered: grep for "MobFinalizeSpawnMixin" in thc.mixins.json
  </verify>
  <done>
MobFinalizeSpawnMixin.java exists and tags naturally-spawned Overworld mobs with SPAWN_REGION (OW_SURFACE/OW_UPPER_CAVE/OW_LOWER_CAVE) and SPAWN_COUNTED (true for monsters).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Build verification:
   ```bash
   ./gradlew build
   ```

2. Manual in-game verification (via NBT viewer mod or /data command):
   - Spawn mob on surface (plains) -> check NBT shows spawnSystem.region = "OW_SURFACE"
   - Spawn mob in cave above Y=0 -> check NBT shows spawnSystem.region = "OW_UPPER_CAVE"
   - Spawn mob in deep cave (Y < 0) -> check NBT shows spawnSystem.region = "OW_LOWER_CAVE"
   - Check hostile mob has spawnSystem.counted = true
   - Spawn mob from dungeon spawner -> no spawn tags present
</verification>

<success_criteria>
1. THCAttachments.java contains SPAWN_REGION and SPAWN_COUNTED attachment definitions
2. MobFinalizeSpawnMixin.java tags mobs at spawn time with region and counted status
3. Mixin registered in thc.mixins.json
4. Build compiles successfully
5. Region detection uses Heightmap.Type.MOTION_BLOCKING for correct overhang handling
6. Only NATURAL and CHUNK_GENERATION spawns are tagged (spawners excluded)
7. Only Overworld mobs are tagged (Nether/End skipped)
</success_criteria>

<output>
After completion, create `.planning/phases/41-nbt-spawn-origin-tagging/41-01-SUMMARY.md`
</output>
