---
phase: 43-monster-cap-partitioning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/spawn/RegionalCapManager.java
  - src/main/java/thc/mixin/NaturalSpawnerMixin.java
  - src/main/java/thc/mixin/SpawnReplacementMixin.java
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Surface cap (21) prevents surface spawns when reached, caves continue"
    - "Upper cave cap (28) prevents upper cave spawns when reached, others continue"
    - "Lower cave cap (35) prevents lower cave spawns when reached, others continue"
    - "Only SPAWN_COUNTED=true mobs contribute to regional counts"
    - "Nether and End spawns bypass regional cap system entirely"
  artifacts:
    - path: "src/main/java/thc/spawn/RegionalCapManager.java"
      provides: "ThreadLocal counting and cap check logic"
      exports: ["countMobsByRegion", "canSpawnInRegion", "clearCounts"]
    - path: "src/main/java/thc/mixin/NaturalSpawnerMixin.java"
      provides: "Spawn cycle hooks for count initialization and cleanup"
      contains: "thc$initRegionalCounts"
    - path: "src/main/java/thc/mixin/SpawnReplacementMixin.java"
      provides: "Cap check integration in spawn redirect"
      contains: "RegionalCapManager.canSpawnInRegion"
  key_links:
    - from: "NaturalSpawnerMixin.thc$initRegionalCounts"
      to: "RegionalCapManager.countMobsByRegion"
      via: "HEAD inject on spawnForChunk"
      pattern: "RegionalCapManager\\.countMobsByRegion"
    - from: "SpawnReplacementMixin.thc$replaceWithSurfaceVariant"
      to: "RegionalCapManager.canSpawnInRegion"
      via: "Cap check before distribution roll"
      pattern: "canSpawnInRegion.*region"
    - from: "RegionalCapManager.countMobsByRegion"
      to: "THCAttachments.SPAWN_COUNTED"
      via: "Attachment read for mob filtering"
      pattern: "SPAWN_COUNTED"
---

<objective>
Implement regional monster caps that enforce independent spawn limits for each Overworld zone.

Purpose: Prevent surface spawns from consuming all monster capacity, ensuring caves maintain their own mob populations regardless of surface activity.

Output: RegionalCapManager utility + mixin hooks that count tagged mobs by region and block spawns when caps are reached. Surface (21), Upper Cave (28), Lower Cave (35) operate independently.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-monster-cap-partitioning/43-RESEARCH.md
@.planning/phases/43-monster-cap-partitioning/43-CONTEXT.md

# Prior phase infrastructure (NBT tagging and regional distribution)
@.planning/phases/42-regional-spawn-system/42-01-SUMMARY.md

# Existing code to extend
@src/main/java/thc/THCAttachments.java
@src/main/java/thc/mixin/NaturalSpawnerMixin.java
@src/main/java/thc/mixin/SpawnReplacementMixin.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RegionalCapManager utility</name>
  <files>src/main/java/thc/spawn/RegionalCapManager.java</files>
  <action>
Create RegionalCapManager.java in src/main/java/thc/spawn/ package with:

1. **ThreadLocal storage** for per-cycle counts:
   ```java
   private static final ThreadLocal<Map<String, Integer>> REGIONAL_COUNTS =
       ThreadLocal.withInitial(HashMap::new);
   ```

2. **Hard-coded caps** per user decision:
   - OW_SURFACE: 21
   - OW_UPPER_CAVE: 28
   - OW_LOWER_CAVE: 35

3. **countMobsByRegion(ServerLevel level)** method:
   - Iterate `level.getAllEntities()`
   - Filter: `entity instanceof Mob`
   - Filter: `mob.getType().getCategory() == MobCategory.MONSTER`
   - Filter: `mob.getAttached(THCAttachments.SPAWN_COUNTED) == Boolean.TRUE`
   - Group by: `mob.getAttached(THCAttachments.SPAWN_REGION)`
   - Store counts in ThreadLocal

4. **canSpawnInRegion(String region)** method:
   - Return true if region is null (non-Overworld uses vanilla caps)
   - Return true if region not in cap map (unknown region)
   - Compare ThreadLocal count against cap, return count < cap

5. **clearCounts()** method:
   - Call `REGIONAL_COUNTS.remove()` to clean up ThreadLocal

Import THCAttachments from thc package. Use MobCategory from net.minecraft.world.entity.
  </action>
  <verify>
File compiles: `./gradlew classes`
Verify exports: grep for public static methods countMobsByRegion, canSpawnInRegion, clearCounts
  </verify>
  <done>RegionalCapManager.java exists with ThreadLocal counting, hard-coded caps (21/28/35), and cap check logic</done>
</task>

<task type="auto">
  <name>Task 2: Add spawn cycle hooks to NaturalSpawnerMixin</name>
  <files>src/main/java/thc/mixin/NaturalSpawnerMixin.java</files>
  <action>
Extend existing NaturalSpawnerMixin with two new @Inject methods:

1. **thc$initRegionalCounts** - HEAD inject on spawnForChunk:
   ```java
   @Inject(
       method = "spawnForChunk",
       at = @At("HEAD")
   )
   private static void thc$initRegionalCounts(
           ServerLevel level, LevelChunk chunk,
           NaturalSpawner.SpawnState state,
           boolean spawnFriendlies, boolean spawnMonsters, boolean spawnMisc,
           CallbackInfo ci) {

       // Only count for Overworld monster spawning
       if (level.dimension() == Level.OVERWORLD && spawnMonsters) {
           RegionalCapManager.countMobsByRegion(level);
       }
   }
   ```

2. **thc$clearRegionalCounts** - RETURN inject on spawnForChunk:
   ```java
   @Inject(
       method = "spawnForChunk",
       at = @At("RETURN")
   )
   private static void thc$clearRegionalCounts(
           ServerLevel level, LevelChunk chunk,
           NaturalSpawner.SpawnState state,
           boolean spawnFriendlies, boolean spawnMonsters, boolean spawnMisc,
           CallbackInfo ci) {

       RegionalCapManager.clearCounts();
   }
   ```

Add required imports:
- net.minecraft.world.level.Level
- net.minecraft.world.level.chunk.LevelChunk
- org.spongepowered.asm.mixin.injection.callback.CallbackInfo
- thc.spawn.RegionalCapManager

Note: spawnForChunk is a static method in NaturalSpawner. The boolean parameters control which mob categories spawn. Per research, check exact parameter names in yarn/mojang mappings for 1.21.11 if compile fails.
  </action>
  <verify>
File compiles: `./gradlew classes`
Verify injections: grep for thc$initRegionalCounts and thc$clearRegionalCounts
  </verify>
  <done>NaturalSpawnerMixin has HEAD and RETURN injections on spawnForChunk calling RegionalCapManager</done>
</task>

<task type="auto">
  <name>Task 3: Integrate cap check into SpawnReplacementMixin</name>
  <files>src/main/java/thc/mixin/SpawnReplacementMixin.java</files>
  <action>
Modify thc$replaceWithSurfaceVariant redirect to add regional cap check:

1. **After passenger check (line ~79), before regional distribution roll**, add cap check:
   ```java
   // Preserve passenger checks (existing)
   if (!entity.getPassengers().isEmpty() || entity.getVehicle() != null) {
       level.addFreshEntityWithPassengers(entity);
       return;
   }

   BlockPos pos = entity.blockPosition();

   // NEW: Detect region for cap check
   String region = thc$detectRegion(level, pos);

   // NEW: Regional cap check - block spawn if cap reached
   if (region != null && !RegionalCapManager.canSpawnInRegion(region)) {
       // Regional cap reached - do not spawn this entity
       // Per spec: fail the attempt, no fallback
       return;
   }

   // EXISTING: Regional distribution roll (unchanged)
   if (region != null) {
       SpawnDistributions.MobSelection selection = SpawnDistributions.selectMob(region, level.random);
       // ... rest of existing code ...
   }
   ```

2. **Add import** at top of file:
   ```java
   import thc.spawn.RegionalCapManager;
   ```

The cap check uses the same region string as distribution selection, ensuring consistent behavior. When cap is reached, the entity is simply not spawned (no fallback, no vanilla spawn).

Per user decision: three INDEPENDENT caps, no global cap applies. Each region can be at 100% simultaneously (84 total mobs possible).
  </action>
  <verify>
File compiles: `./gradlew classes`
Verify integration: grep for RegionalCapManager.canSpawnInRegion in SpawnReplacementMixin
  </verify>
  <done>SpawnReplacementMixin checks regional cap before distribution roll, blocks spawn if cap reached</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile check:**
   ```bash
   ./gradlew classes
   ```

2. **Static verification:**
   - RegionalCapManager exists with countMobsByRegion, canSpawnInRegion, clearCounts
   - NaturalSpawnerMixin has thc$initRegionalCounts and thc$clearRegionalCounts
   - SpawnReplacementMixin imports and calls RegionalCapManager.canSpawnInRegion

3. **Integration check:**
   - thc$detectRegion called once per spawn attempt (reused for both cap check and distribution)
   - Cap check happens BEFORE distribution roll (no wasted computation)
   - clearCounts called on every spawnForChunk return (no ThreadLocal leaks)

4. **Cap value verification:**
   - Surface: 21 (30% of 70)
   - Upper Cave: 28 (40% of 70)
   - Lower Cave: 35 (50% of 70)
</verification>

<success_criteria>
1. RegionalCapManager.java created with ThreadLocal counting and hard-coded caps
2. NaturalSpawnerMixin hooks spawn cycle start/end
3. SpawnReplacementMixin checks caps before spawning
4. `./gradlew classes` compiles without errors
5. All three regional caps are independent (no global cap applies)
</success_criteria>

<output>
After completion, create `.planning/phases/43-monster-cap-partitioning/43-01-SUMMARY.md`
</output>
