---
phase: 54-lectern-enchanting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/thc/enchant/EnchantmentEnforcement.kt
  - src/main/kotlin/thc/lectern/LecternEnchanting.kt
  - src/main/kotlin/thc/THC.kt
autonomous: false

must_haves:
  truths:
    - "Stage 1-2 enchantment books can be placed on empty lecterns"
    - "Right-clicking lectern with compatible gear applies the enchantment"
    - "Book remains on lectern after enchanting (unlimited use)"
    - "Players below level 10 see 'You must be level 10!' message"
    - "Enchanting costs 3 levels"
    - "Stage 3+ books rejected with 'This enchantment requires an enchanting table!'"
  artifacts:
    - path: "src/main/kotlin/thc/enchant/EnchantmentEnforcement.kt"
      provides: "STAGE_1_2_ENCHANTMENTS set for lectern validation"
      contains: "STAGE_1_2_ENCHANTMENTS"
    - path: "src/main/kotlin/thc/lectern/LecternEnchanting.kt"
      provides: "UseBlockCallback handler for lectern interactions"
      exports: ["register"]
    - path: "src/main/kotlin/thc/THC.kt"
      provides: "LecternEnchanting.register() initialization"
      contains: "LecternEnchanting.register"
  key_links:
    - from: "src/main/kotlin/thc/lectern/LecternEnchanting.kt"
      to: "UseBlockCallback.EVENT"
      via: "register callback"
      pattern: "UseBlockCallback.EVENT.register"
    - from: "src/main/kotlin/thc/lectern/LecternEnchanting.kt"
      to: "EnchantmentEnforcement.STAGE_1_2_ENCHANTMENTS"
      via: "stage validation"
      pattern: "STAGE_1_2_ENCHANTMENTS.contains"
---

<objective>
Implement lectern enchanting system where players can place stage 1-2 enchantment books on lecterns and repeatedly enchant compatible gear at level cost.

Purpose: Enable early-game enchanting progression through lecterns with unlimited book reuse, distinct from enchanting tables for stage 3+ enchantments.

Output: Working lectern interaction system with book placement, gear enchanting, level requirements, and stage gating.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-lectern-enchanting/54-CONTEXT.md
@.planning/phases/54-lectern-enchanting/54-RESEARCH.md
@.planning/phases/53-enforcement-foundation/53-01-SUMMARY.md

# Key existing code
@src/main/kotlin/thc/enchant/EnchantmentEnforcement.kt
@src/main/kotlin/thc/bell/BellHandler.kt
@src/main/kotlin/thc/THC.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Stage 1-2 Enchantment Set</name>
  <files>src/main/kotlin/thc/enchant/EnchantmentEnforcement.kt</files>
  <action>
Add STAGE_1_2_ENCHANTMENTS set to EnchantmentEnforcement.kt containing enchantments allowed on lecterns.

Stage 1-2 enchantments (early-game, basic effects):
```kotlin
val STAGE_1_2_ENCHANTMENTS = setOf(
    // Damage enchantments (basic)
    "minecraft:sharpness",
    "minecraft:power",
    "minecraft:smite",
    "minecraft:bane_of_arthropods",

    // Defense enchantments (all protection types)
    "minecraft:protection",
    "minecraft:fire_protection",
    "minecraft:blast_protection",
    "minecraft:projectile_protection",
    "minecraft:feather_falling",

    // Tool enchantments (basic utility)
    "minecraft:efficiency",
    "minecraft:unbreaking",
    "minecraft:silk_touch",

    // Crossbow basic
    "minecraft:piercing",

    // Fishing basic
    "minecraft:lure",
    "minecraft:luck_of_the_sea"
)
```

Also add helper method:
```kotlin
fun isStage12Enchantment(enchantId: String?): Boolean {
    return enchantId != null && STAGE_1_2_ENCHANTMENTS.contains(enchantId)
}
```

NOTE: Fortune and Looting are stage 3+ (powerful economy impact). Mending, respiration, aqua affinity, depth strider, frost walker are stage 3+ (mob drops per phase 56). Flame, Fire Aspect are stage 3+ (powerful damage). Sweeping edge, knockback, punch already in REMOVED_ENCHANTMENTS.
  </action>
  <verify>`./gradlew build` compiles without errors</verify>
  <done>STAGE_1_2_ENCHANTMENTS set exists with 16 enchantments, isStage12Enchantment helper available</done>
</task>

<task type="auto">
  <name>Task 2: Implement Lectern Enchanting Handler</name>
  <files>src/main/kotlin/thc/lectern/LecternEnchanting.kt, src/main/kotlin/thc/THC.kt</files>
  <action>
Create LecternEnchanting.kt following BellHandler.kt pattern with UseBlockCallback.

```kotlin
package thc.lectern

import net.fabricmc.fabric.api.event.player.UseBlockCallback
import net.minecraft.core.component.DataComponents
import net.minecraft.core.particles.ParticleTypes
import net.minecraft.network.chat.Component
import net.minecraft.server.level.ServerLevel
import net.minecraft.sounds.SoundEvents
import net.minecraft.sounds.SoundSource
import net.minecraft.world.InteractionResult
import net.minecraft.world.item.Items
import net.minecraft.world.item.enchantment.Enchantment
import net.minecraft.world.item.enchantment.EnchantmentHelper
import net.minecraft.world.item.enchantment.ItemEnchantments
import net.minecraft.world.level.block.Blocks
import net.minecraft.world.level.block.LecternBlock
import net.minecraft.world.level.block.entity.LecternBlockEntity
import thc.enchant.EnchantmentEnforcement

object LecternEnchanting {

    @JvmStatic
    fun register() {
        UseBlockCallback.EVENT.register { player, level, hand, hitResult ->
            val pos = hitResult.blockPos
            val blockState = level.getBlockState(pos)

            // Only handle lecterns
            if (!blockState.`is`(Blocks.LECTERN)) {
                return@register InteractionResult.PASS
            }

            // Server-side only processing
            if (level.isClientSide) {
                return@register InteractionResult.SUCCESS
            }

            val itemInHand = player.getItemInHand(hand)
            val hasBook = blockState.getValue(LecternBlock.HAS_BOOK)
            val blockEntity = level.getBlockEntity(pos) as? LecternBlockEntity

            // Shift+right-click: Remove book from lectern
            if (player.isShiftKeyDown && hasBook && blockEntity != null) {
                val storedBook = blockEntity.book
                if (!storedBook.isEmpty && storedBook.`is`(Items.ENCHANTED_BOOK)) {
                    // Give book back to player
                    if (!player.inventory.add(storedBook.copy())) {
                        player.drop(storedBook.copy(), false)
                    }
                    // Clear lectern
                    blockEntity.setBook(net.minecraft.world.item.ItemStack.EMPTY)
                    level.setBlock(pos, blockState.setValue(LecternBlock.HAS_BOOK, false), 3)
                    return@register InteractionResult.SUCCESS
                }
            }

            // Right-click with enchanted book: Place on empty lectern
            if (itemInHand.`is`(Items.ENCHANTED_BOOK) && !hasBook) {
                val storedEnchants = itemInHand.get(DataComponents.STORED_ENCHANTMENTS)
                if (storedEnchants != null && !storedEnchants.isEmpty) {
                    // Check if ALL enchantments are stage 1-2
                    for (entry in storedEnchants.entrySet()) {
                        val enchantId = entry.key.unwrapKey().orElse(null)?.location()?.toString()
                        if (!EnchantmentEnforcement.isStage12Enchantment(enchantId)) {
                            player.displayClientMessage(
                                Component.literal("This enchantment requires an enchanting table!"),
                                true
                            )
                            return@register InteractionResult.FAIL
                        }
                    }

                    // Place book on lectern
                    if (blockEntity != null) {
                        blockEntity.setBook(itemInHand.copy())
                        level.setBlock(pos, blockState.setValue(LecternBlock.HAS_BOOK, true), 3)

                        // Remove book from player hand
                        itemInHand.shrink(1)

                        return@register InteractionResult.SUCCESS
                    }
                }
                return@register InteractionResult.PASS
            }

            // Right-click with gear: Apply enchantment from lectern book
            if (hasBook && blockEntity != null && !itemInHand.isEmpty && !itemInHand.`is`(Items.ENCHANTED_BOOK)) {
                val storedBook = blockEntity.book
                if (storedBook.isEmpty || !storedBook.`is`(Items.ENCHANTED_BOOK)) {
                    return@register InteractionResult.PASS
                }

                val storedEnchants = storedBook.get(DataComponents.STORED_ENCHANTMENTS)
                    ?: return@register InteractionResult.PASS

                if (storedEnchants.isEmpty) {
                    return@register InteractionResult.PASS
                }

                // Check level requirement
                if (player.experienceLevel < 10) {
                    player.displayClientMessage(
                        Component.literal("You must be level 10!"),
                        true
                    )
                    return@register InteractionResult.FAIL
                }

                // Check compatibility
                val targetEnchants = itemInHand.get(DataComponents.ENCHANTMENTS) ?: ItemEnchantments.EMPTY

                for (entry in storedEnchants.entrySet()) {
                    val enchantHolder = entry.key

                    // Already has this enchantment?
                    if (targetEnchants.getLevel(enchantHolder) > 0) {
                        player.displayClientMessage(
                            Component.literal("Already applied!"),
                            true
                        )
                        return@register InteractionResult.FAIL
                    }

                    // Can this enchantment go on this item?
                    if (!enchantHolder.value().canEnchant(itemInHand)) {
                        player.displayClientMessage(
                            Component.literal("Incompatible enchantment!"),
                            true
                        )
                        return@register InteractionResult.FAIL
                    }

                    // Conflicts with existing enchantments?
                    for (existing in targetEnchants.keySet()) {
                        if (!Enchantment.areCompatible(enchantHolder, existing)) {
                            player.displayClientMessage(
                                Component.literal("Incompatible enchantment!"),
                                true
                            )
                            return@register InteractionResult.FAIL
                        }
                    }
                }

                // Apply enchantments
                EnchantmentHelper.updateEnchantments(itemInHand) { mutable ->
                    for (entry in storedEnchants.entrySet()) {
                        mutable.set(entry.key, entry.intValue)
                    }
                }

                // Deduct levels
                player.giveExperienceLevels(-3)

                // Play feedback
                val serverLevel = level as? ServerLevel
                if (serverLevel != null) {
                    // Sound
                    serverLevel.playSound(
                        null,
                        pos,
                        SoundEvents.ENCHANTMENT_TABLE_USE,
                        SoundSource.BLOCKS,
                        1.0f,
                        1.0f
                    )

                    // Particles around player
                    val random = serverLevel.random
                    for (i in 0 until 15) {
                        serverLevel.sendParticles(
                            ParticleTypes.ENCHANT,
                            player.x + random.nextGaussian() * 0.3,
                            player.y + 1.0 + random.nextGaussian() * 0.3,
                            player.z + random.nextGaussian() * 0.3,
                            1, 0.0, 0.0, 0.0, 0.0
                        )
                    }
                }

                return@register InteractionResult.SUCCESS
            }

            // Let vanilla handle other interactions
            InteractionResult.PASS
        }
    }
}
```

Add registration in THC.kt onInitialize():
```kotlin
import thc.lectern.LecternEnchanting

// In onInitialize():
LecternEnchanting.register()
```

IMPORTANT: Use `location()?.toString()` not `identifier()?.toString()` for enchantment ID - verify the correct method name exists in MC 1.21.11 ResourceKey API. If `location()` doesn't exist, check for `value()` or `getId()` pattern.
  </action>
  <verify>
1. `./gradlew build` compiles without errors
2. `./gradlew runClient` launches (manual smoke test)
  </verify>
  <done>LecternEnchanting handler registered, all interaction paths implemented (book placement, enchanting, removal, error states)</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete lectern enchanting system with book placement, gear enchanting, level requirements, and stage gating</what-built>
  <how-to-verify>
1. Launch client: `./gradlew runClient`
2. Give yourself test items:
   - `/give @p enchanted_book{StoredEnchantments:[{id:"minecraft:sharpness",lvl:1}]} 1` (stage 1-2 book)
   - `/give @p enchanted_book{StoredEnchantments:[{id:"minecraft:fortune",lvl:3}]} 1` (stage 3+ book for rejection test)
   - `/give @p diamond_sword 1`
   - `/give @p lectern 1`
3. Place lectern
4. Right-click lectern with fortune book - should see "This enchantment requires an enchanting table!" in action bar
5. Right-click lectern with sharpness book - book should be placed on lectern
6. Set level below 10: `/xp set @p 5 levels`
7. Right-click lectern with sword - should see "You must be level 10!"
8. Set level to 10+: `/xp set @p 15 levels`
9. Right-click lectern with sword - should enchant, hear sound, see particles, lose 3 levels
10. Right-click lectern with same sword again - should see "Already applied!"
11. Shift+right-click lectern - book should return to inventory
12. Verify lectern shows as empty after book removal
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
After all tasks:
1. Build succeeds: `./gradlew build`
2. Stage 1-2 set defined in EnchantmentEnforcement
3. LecternEnchanting handler registered in THC
4. All interaction paths work (placement, enchanting, removal, rejections)
5. Level requirement enforced (10 minimum)
6. Level cost applied (3 levels)
7. Stage 3+ books rejected
</verification>

<success_criteria>
- Stage 1-2 enchantment books can be placed on empty lecterns by right-clicking
- Right-clicking a lectern holding a book while holding compatible gear applies the enchantment
- Enchantment book remains on lectern after use (unlimited applications)
- Lectern enchanting requires player level 10 minimum and costs 3 levels
- Players below level 10 see action bar message "You must be level 10!" when attempting to enchant
- Stage 3+ books rejected with message
</success_criteria>

<output>
After completion, create `.planning/phases/54-lectern-enchanting/54-01-SUMMARY.md`
</output>
