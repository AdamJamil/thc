---
phase: 55-enchanting-table-overhaul
plan: 03
type: execute
wave: 2
depends_on: ["55-01"]
files_modified:
  - src/main/java/thc/mixin/EnchantmentMenuMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "Enchanting table GUI shows one button (not three RNG options)"
    - "Enchanted book in slot determines exact enchantment applied"
    - "Button disabled when fewer than 15 bookshelves"
    - "Button disabled when player level below requirement (10/20/30 by stage)"
    - "Enchanting costs 3 levels regardless of enchantment"
    - "Book remains in slot after enchanting (unlimited uses)"
  artifacts:
    - path: "src/main/java/thc/mixin/EnchantmentMenuMixin.java"
      provides: "Deterministic book-slot enchanting menu behavior"
      contains: "thc$calculateBookEnchantCosts"
    - path: "src/main/resources/thc.mixins.json"
      provides: "Mixin registration"
      contains: "EnchantmentMenuMixin"
  key_links:
    - from: "EnchantmentMenuMixin.java"
      to: "EnchantmentEnforcement.kt"
      via: "getStageForEnchantment and getLevelRequirementForStage calls"
    - from: "EnchantmentMenuMixin.java"
      to: "EnchantmentHelper"
      via: "updateEnchantments() for applying enchantment"
---

<objective>
Create EnchantmentMenuMixin for deterministic book-slot enchanting.

Purpose: Replaces RNG-based enchanting with deterministic book-slot mechanic where the enchanted book determines exactly what enchantment is applied.
Output: EnchantmentMenuMixin.java with HEAD cancellation on cost calculation, click handling, and slots changed.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-enchanting-table-overhaul/55-RESEARCH.md
@src/main/java/thc/mixin/AnvilMenuMixin.java
@src/main/kotlin/thc/lectern/LecternEnchanting.kt
@src/main/kotlin/thc/enchant/EnchantmentEnforcement.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EnchantmentMenuMixin with cost calculation</name>
  <files>
    src/main/java/thc/mixin/EnchantmentMenuMixin.java
    src/main/resources/thc.mixins.json
  </files>
  <action>
Create EnchantmentMenuMixin.java following the AnvilMenuMixin pattern.

Key elements:
1. Extend AbstractContainerMenu with dummy constructor
2. @Shadow fields: enchantSlots (Container), access (ContainerLevelAccess), costs (int[]), enchantClue (int[]), levelClue (int[])
3. HEAD injection on method_17411 (cost calculation) to replace RNG with book-based costs

```java
package thc.mixin;

import net.minecraft.core.BlockPos;
import net.minecraft.core.Holder;
import net.minecraft.core.component.DataComponents;
import net.minecraft.world.Container;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.ContainerLevelAccess;
import net.minecraft.world.inventory.EnchantmentMenu;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.enchantment.Enchantment;
import net.minecraft.world.item.enchantment.ItemEnchantments;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.EnchantingTableBlock;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
import thc.enchant.EnchantmentEnforcement;

@Mixin(EnchantmentMenu.class)
public abstract class EnchantmentMenuMixin extends AbstractContainerMenu {

    @Shadow @Final private Container enchantSlots;
    @Shadow @Final private ContainerLevelAccess access;
    @Shadow public final int[] costs = new int[3];
    @Shadow public final int[] enchantClue = new int[3];
    @Shadow public final int[] levelClue = new int[3];

    protected EnchantmentMenuMixin() { super(null, 0); }

    @Inject(method = "method_17411", at = @At("HEAD"), cancellable = true)
    private void thc$calculateBookEnchantCosts(ItemStack itemStack, Level level, BlockPos pos, CallbackInfo ci) {
        // Reset all costs (hides buttons 1 and 2)
        costs[0] = 0;
        costs[1] = 0;
        costs[2] = 0;
        enchantClue[0] = -1;
        enchantClue[1] = -1;
        enchantClue[2] = -1;
        levelClue[0] = -1;
        levelClue[1] = -1;
        levelClue[2] = -1;

        // Count bookshelves (vanilla max is 15)
        int bookshelfCount = 0;
        for (BlockPos offset : EnchantingTableBlock.BOOKSHELF_OFFSETS) {
            if (EnchantingTableBlock.isValidBookShelf(level, pos, offset)) {
                bookshelfCount++;
            }
        }

        // Require 15 bookshelves (all valid positions filled)
        if (bookshelfCount < 15) {
            ci.cancel();
            return;
        }

        // Get item and book from slots
        ItemStack item = enchantSlots.getItem(0);
        ItemStack book = enchantSlots.getItem(1);

        // Need both item to enchant and enchanted book
        if (item.isEmpty() || !book.is(Items.ENCHANTED_BOOK)) {
            ci.cancel();
            return;
        }

        // Get enchantment from book
        ItemEnchantments storedEnchants = book.get(DataComponents.STORED_ENCHANTMENTS);
        if (storedEnchants == null || storedEnchants.isEmpty()) {
            ci.cancel();
            return;
        }

        // Get first enchantment (require single-enchantment books)
        var entries = storedEnchants.entrySet().iterator();
        if (!entries.hasNext()) {
            ci.cancel();
            return;
        }
        var entry = entries.next();

        // Reject multi-enchantment books
        if (entries.hasNext()) {
            ci.cancel();
            return;
        }

        Holder<Enchantment> enchantHolder = entry.getKey();
        String enchantId = enchantHolder.unwrapKey().orElse(null) != null
            ? enchantHolder.unwrapKey().get().identifier().toString()
            : null;

        // Check compatibility
        if (!thc$isCompatible(enchantHolder, item)) {
            ci.cancel();
            return;
        }

        // Get level requirement based on stage
        int stage = EnchantmentEnforcement.INSTANCE.getStageForEnchantment(enchantId);
        int levelReq = EnchantmentEnforcement.INSTANCE.getLevelRequirementForStage(stage);

        // Set cost for button 0 (only button we use)
        costs[0] = levelReq;

        ci.cancel();
    }

    @Unique
    private boolean thc$isCompatible(Holder<Enchantment> enchantHolder, ItemStack item) {
        // Can this enchantment go on this item type?
        if (!enchantHolder.value().canEnchant(item)) {
            return false;
        }

        // Check for duplicates and conflicts
        ItemEnchantments existingEnchants = item.get(DataComponents.ENCHANTMENTS);
        if (existingEnchants != null) {
            // Already has this exact enchantment?
            if (existingEnchants.getLevel(enchantHolder) > 0) {
                return false;
            }

            // Conflicts with existing enchantments?
            for (Holder<Enchantment> existing : existingEnchants.keySet()) {
                if (!Enchantment.areCompatible(enchantHolder, existing)) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

Add "EnchantmentMenuMixin" to thc.mixins.json in the mixins array.
  </action>
  <verify>Run `./gradlew build`. Verify mixin compiles and is registered.</verify>
  <done>EnchantmentMenuMixin created with cost calculation method that enforces 15 bookshelves and shows level requirement in button.</done>
</task>

<task type="auto">
  <name>Task 2: Add click handler for enchantment application</name>
  <files>src/main/java/thc/mixin/EnchantmentMenuMixin.java</files>
  <action>
Add clickMenuButton HEAD injection to EnchantmentMenuMixin.java for deterministic enchantment application.

Add imports:
```java
import net.minecraft.world.item.enchantment.EnchantmentHelper;
import net.minecraft.server.level.ServerPlayer;
```

Add the click handler method after thc$isCompatible:

```java
@Inject(method = "clickMenuButton", at = @At("HEAD"), cancellable = true)
private void thc$applyBookEnchantment(Player player, int buttonId, CallbackInfoReturnable<Boolean> cir) {
    // Only handle button 0 (our single enchant button)
    if (buttonId != 0) {
        cir.setReturnValue(false);
        return;
    }

    // Verify cost is set (button should be visible)
    if (costs[0] <= 0) {
        cir.setReturnValue(false);
        return;
    }

    // Check player level
    if (player.experienceLevel < costs[0]) {
        cir.setReturnValue(false);
        return;
    }

    // Get item and book
    ItemStack item = enchantSlots.getItem(0);
    ItemStack book = enchantSlots.getItem(1);

    if (item.isEmpty() || !book.is(Items.ENCHANTED_BOOK)) {
        cir.setReturnValue(false);
        return;
    }

    ItemEnchantments storedEnchants = book.get(DataComponents.STORED_ENCHANTMENTS);
    if (storedEnchants == null || storedEnchants.isEmpty()) {
        cir.setReturnValue(false);
        return;
    }

    // Re-validate bookshelves on server
    access.execute((level, pos) -> {
        int bookshelfCount = 0;
        for (BlockPos offset : EnchantingTableBlock.BOOKSHELF_OFFSETS) {
            if (EnchantingTableBlock.isValidBookShelf(level, pos, offset)) {
                bookshelfCount++;
            }
        }
        if (bookshelfCount < 15) {
            return;
        }

        // Get first enchantment from book
        var entry = storedEnchants.entrySet().iterator().next();
        Holder<Enchantment> enchantHolder = entry.getKey();

        // Final compatibility check
        if (!thc$isCompatible(enchantHolder, item)) {
            return;
        }

        // Apply enchantment using the proven LecternEnchanting pattern
        EnchantmentHelper.updateEnchantments(item, mutable -> {
            mutable.set(enchantHolder, entry.getIntValue());
        });

        // Deduct 3 levels (always 3 per CONTEXT.md)
        player.giveExperienceLevels(-3);

        // Play sound
        level.playSound(null, pos, net.minecraft.sounds.SoundEvents.ENCHANTMENT_TABLE_USE,
            net.minecraft.sounds.SoundSource.BLOCKS, 1.0f, 1.0f);

        // Broadcast slot changes
        this.broadcastChanges();
    });

    cir.setReturnValue(true);
}
```

Note: Book stays in slot after enchanting (unlimited uses) - we don't call book.shrink(1).
  </action>
  <verify>Run `./gradlew build`. Verify clickMenuButton handler exists in EnchantmentMenuMixin.</verify>
  <done>Click handler applies enchantment from book to item, costs 3 levels, keeps book in slot.</done>
</task>

</tasks>

<verification>
1. `./gradlew build` completes successfully
2. EnchantmentMenuMixin.java contains thc$calculateBookEnchantCosts and thc$applyBookEnchantment methods
3. thc.mixins.json includes "EnchantmentMenuMixin" in mixins array
4. Mixin uses EnchantmentEnforcement stage classification for level requirements
</verification>

<success_criteria>
- Build passes
- Mixin registered in thc.mixins.json
- Cost calculation requires 15 bookshelves, single-enchantment book, compatible item
- Click handler applies enchantment, costs 3 levels, keeps book in slot
- Level requirement varies by stage (10/20/30)
</success_criteria>

<output>
After completion, create `.planning/phases/55-enchanting-table-overhaul/55-03-SUMMARY.md`
</output>
