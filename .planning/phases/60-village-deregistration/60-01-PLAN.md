---
phase: 60-village-deregistration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/mixin/ServerLevelPoiMixin.java
  - src/main/java/thc/mixin/BrainPoiMemoryMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "Beds placed in claimed chunks do not register as village POI"
    - "Villagers cannot claim beds located in claimed chunks"
    - "Villages in unclaimed territory function normally"
    - "Existing village mechanics outside claimed chunks are unaffected"
  artifacts:
    - path: "src/main/java/thc/mixin/ServerLevelPoiMixin.java"
      provides: "POI registration blocking in claimed chunks"
      contains: "thc$blockPoiInClaimedChunks"
    - path: "src/main/java/thc/mixin/BrainPoiMemoryMixin.java"
      provides: "Villager POI claiming prevention in claimed chunks"
      contains: "thc$blockPoiClaimInClaimedChunks"
  key_links:
    - from: "ServerLevelPoiMixin.java"
      to: "ClaimManager.isClaimed"
      via: "HEAD injection on updatePOIOnBlockStateChange"
      pattern: "ClaimManager\\.INSTANCE\\.isClaimed"
    - from: "BrainPoiMemoryMixin.java"
      to: "ClaimManager.isClaimed"
      via: "HEAD injection on setMemory"
      pattern: "ClaimManager\\.INSTANCE\\.isClaimed"
---

<objective>
Prevent beds and villagers in claimed chunks from registering to village mechanics.

Purpose: Players claiming a chunk should decouple it from village mechanics - beds won't count towards village population and villagers in that chunk won't be counted. This gives players control over their territory without inadvertently affecting nearby villages.

Output: Two mixins implementing a two-layer defense: (1) POI registration blocking when beds are placed in claimed chunks via ServerLevel interception, (2) villager POI memory blocking via Brain.setMemory interception.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/60-village-deregistration/60-RESEARCH.md

# Existing patterns for chunk claim checks
@src/main/java/thc/mixin/NaturalSpawnerMixin.java
@src/main/kotlin/thc/claim/ClaimManager.kt

# Existing villager mixin (separate concern - twilight schedule)
@src/main/java/thc/mixin/VillagerMixin.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ServerLevelPoiMixin for POI Registration Blocking</name>
  <files>
    src/main/java/thc/mixin/ServerLevelPoiMixin.java
    src/main/resources/thc.mixins.json
  </files>
  <action>
Create ServerLevelPoiMixin.java to block POI registration in claimed chunks.

**Why ServerLevel instead of PoiManager:**
Research confirmed PoiManager.add(BlockPos, Holder<PoiType>) has NO server access - it only stores the POI. The ServerLevel.updatePOIOnBlockStateChange method is the upstream caller that:
1. Has direct server access via `this.getServer()`
2. Is called when any POI-eligible block (bed, workstation, bell) is placed/removed
3. Method signature: `void updatePOIOnBlockStateChange(BlockPos pos, BlockState oldState, BlockState newState)`

**Implementation:**
```java
package thc.mixin;

import net.minecraft.core.BlockPos;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.ChunkPos;
import net.minecraft.world.level.block.state.BlockState;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import thc.claim.ClaimManager;

/**
 * Block POI registration for beds/workstations/bells in claimed chunks.
 *
 * <p>When a POI-eligible block is placed in a claimed chunk, this mixin
 * cancels the POI registration, preventing villagers from seeing it as
 * part of a village.
 */
@Mixin(ServerLevel.class)
public class ServerLevelPoiMixin {

    @Inject(
        method = "updatePOIOnBlockStateChange",
        at = @At("HEAD"),
        cancellable = true
    )
    private void thc$blockPoiInClaimedChunks(
            BlockPos pos,
            BlockState oldState,
            BlockState newState,
            CallbackInfo ci) {

        ServerLevel self = (ServerLevel) (Object) this;
        ChunkPos chunkPos = new ChunkPos(pos);

        if (ClaimManager.INSTANCE.isClaimed(self.getServer(), chunkPos)) {
            ci.cancel(); // Block POI registration/removal in claimed chunks
        }
    }
}
```

**Register mixin:** Add "ServerLevelPoiMixin" to thc.mixins.json mixins array.

**Note:** This intercepts BOTH addition AND removal of POI. If a bed is removed in a claimed chunk, the POI removal is also blocked. This is acceptable - POI in claimed chunks should be ignored entirely.
  </action>
  <verify>
`./gradlew build` compiles successfully.
Mixin class exists at src/main/java/thc/mixin/ServerLevelPoiMixin.java.
Mixin is registered in thc.mixins.json.
  </verify>
  <done>
ServerLevelPoiMixin blocks POI registration for beds, job sites, and bells placed in claimed chunks by intercepting ServerLevel.updatePOIOnBlockStateChange with HEAD cancellation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BrainPoiMemoryMixin for Villager Claiming Prevention</name>
  <files>
    src/main/java/thc/mixin/BrainPoiMemoryMixin.java
    src/main/resources/thc.mixins.json
  </files>
  <action>
Create BrainPoiMemoryMixin.java to prevent villagers from claiming POI in claimed chunks.

This is the second layer of defense - even if POI exists (from before a chunk was claimed), villagers shouldn't be able to store beds or job sites in their brain memory.

**Target method (from research):**
`Brain.setMemory(MemoryModuleType<U>, U)` with descriptor `(Lnet/minecraft/world/entity/ai/memory/MemoryModuleType;Ljava/lang/Object;)V`

This is called when villagers acquire HOME, JOB_SITE, or MEETING_POINT memories.

**Challenge: Getting server context from Brain:**
Brain doesn't have a direct owner reference. We need to use a different approach - target the method that CALLS setMemory with POI data, which has server context.

**Alternative approach - use @Accessor on Brain's owner:**
Actually, Brain doesn't store owner. The better approach is to mixin at the Villager level where memory setting happens WITH villager context.

**Best approach: Mixin on AcquirePoi behavior result:**
Research shows AcquirePoi.create has a `BiPredicate<ServerLevel, BlockPos>` parameter for filtering POI positions. We can wrap this predicate.

**SIMPLEST approach that works:**
Since `Brain.setMemory` is generic and lacks entity context, target `Villager.releasePoi` or a villager-specific method. BUT: we can use a trick - inject on Brain.setMemory and get context via Thread context or check if the memory type is POI-related and the value is GlobalPos.

**Final implementation - Target setMemory with GlobalPos check:**

```java
package thc.mixin;

import net.minecraft.core.BlockPos;
import net.minecraft.core.GlobalPos;
import net.minecraft.server.MinecraftServer;
import net.minecraft.world.entity.ai.Brain;
import net.minecraft.world.entity.ai.memory.MemoryModuleType;
import net.minecraft.world.level.ChunkPos;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import thc.claim.ClaimManager;

/**
 * Block villagers from storing POI memories for locations in claimed chunks.
 *
 * <p>Intercepts Brain.setMemory to check if the value being stored is a
 * GlobalPos (used for HOME, JOB_SITE, MEETING_POINT memories). If the
 * position is in a claimed chunk, the memory setting is cancelled.
 */
@Mixin(Brain.class)
public class BrainPoiMemoryMixin {

    /**
     * Block POI memory storage when the target position is in a claimed chunk.
     *
     * <p>Only blocks GlobalPos values (POI locations). Other memory types pass through.
     * Uses MinecraftServer.getServer() to access the server instance since Brain
     * doesn't have an owner reference.
     */
    @Inject(
        method = "setMemory(Lnet/minecraft/world/entity/ai/memory/MemoryModuleType;Ljava/lang/Object;)V",
        at = @At("HEAD"),
        cancellable = true
    )
    private <U> void thc$blockPoiClaimInClaimedChunks(
            MemoryModuleType<U> type,
            U value,
            CallbackInfo ci) {

        // Only process GlobalPos values (HOME, JOB_SITE, MEETING_POINT use GlobalPos)
        if (!(value instanceof GlobalPos globalPos)) {
            return;
        }

        // Check if this is a POI-related memory type
        if (type != MemoryModuleType.HOME &&
            type != MemoryModuleType.JOB_SITE &&
            type != MemoryModuleType.POTENTIAL_JOB_SITE &&
            type != MemoryModuleType.MEETING_POINT) {
            return;
        }

        // Get server via static accessor (works in server context)
        // Note: This will be null on client, but POI claiming only happens server-side
        MinecraftServer server = net.minecraft.server.MinecraftServer.getServer();
        if (server == null) {
            return; // Client-side or no server context, allow through
        }

        BlockPos pos = globalPos.pos();
        ChunkPos chunkPos = new ChunkPos(pos);

        if (ClaimManager.INSTANCE.isClaimed(server, chunkPos)) {
            ci.cancel(); // Block memory storage for POI in claimed chunks
        }
    }
}
```

**Important notes:**
1. Uses `MinecraftServer.getServer()` static method to get server instance
2. Only blocks GlobalPos values (POI types), not other brain memories
3. Checks memory type to only intercept POI-related memories (HOME, JOB_SITE, etc.)
4. Safe on client (returns early if server is null)

**Register mixin:** Add "BrainPoiMemoryMixin" to thc.mixins.json mixins array.

**If MinecraftServer.getServer() doesn't exist in 1.21.11:**
Use `net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents` to track the current server, or use a ThreadLocal pattern. Check the actual Minecraft API during implementation.
  </action>
  <verify>
`./gradlew build` compiles successfully.
Mixin class exists at src/main/java/thc/mixin/BrainPoiMemoryMixin.java.
Mixin is registered in thc.mixins.json.
  </verify>
  <done>
BrainPoiMemoryMixin prevents villagers from claiming beds, job sites, or meeting points located in claimed chunks by intercepting Brain.setMemory and cancelling GlobalPos storage for POI-related memory types when the position is in a claimed chunk.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `./gradlew build` completes without errors
2. Both mixins are registered in thc.mixins.json
3. ServerLevelPoiMixin contains HEAD injection on updatePOIOnBlockStateChange with ClaimManager check
4. BrainPoiMemoryMixin contains HEAD injection on setMemory with GlobalPos/ClaimManager check
5. Manual test: Place bed in claimed chunk, spawn villager nearby - villager should NOT claim the bed
</verification>

<success_criteria>
1. Beds placed in claimed chunks do not appear in POI system (blocked at ServerLevel)
2. Villagers cannot claim beds/job sites in claimed chunks (blocked at Brain.setMemory)
3. Villages in unclaimed chunks function normally (claim check returns false, normal flow proceeds)
4. Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/60-village-deregistration/60-01-SUMMARY.md`
</output>
