---
phase: 68-custom-trade-tables
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/villager/CustomTradeTables.java
  - src/main/java/thc/mixin/VillagerTradesMixin.java
  - src/main/resources/thc.mixins.json
autonomous: true

must_haves:
  truths:
    - "VillagerTradesMixin intercepts updateTrades() at HEAD and cancels for custom professions"
    - "CustomTradeTables.hasCustomTrades() returns true for librarian, butcher, mason, cartographer"
    - "CustomTradeTables.getTradesFor() returns empty list for levels without trade implementation yet"
  artifacts:
    - path: "src/main/java/thc/villager/CustomTradeTables.java"
      provides: "Trade table data structure and factory methods"
      contains: "hasCustomTrades"
    - path: "src/main/java/thc/mixin/VillagerTradesMixin.java"
      provides: "Trade generation interception"
      contains: "@Inject"
  key_links:
    - from: "VillagerTradesMixin"
      to: "CustomTradeTables"
      via: "hasCustomTrades() and getTradesFor() calls"
      pattern: "CustomTradeTables\\.(hasCustomTrades|getTradesFor)"
---

<objective>
Create the trade table foundation: CustomTradeTables helper class with scaffold structure and VillagerTradesMixin to intercept trade generation for the 4 allowed professions.

Purpose: Establish the hook that replaces vanilla random trade pools with THC deterministic tables. All trade content will be added in subsequent plans.
Output: Working trade interception infrastructure with placeholder trade generation.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/68-custom-trade-tables/68-CONTEXT.md
@.planning/phases/68-custom-trade-tables/68-RESEARCH.md
@src/main/java/thc/mixin/AbstractVillagerMixin.java
@src/main/resources/thc.mixins.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomTradeTables scaffold</name>
  <files>src/main/java/thc/villager/CustomTradeTables.java</files>
  <action>
Create a new Java file `src/main/java/thc/villager/CustomTradeTables.java` with:

1. Package `thc.villager`

2. Required imports:
   - `net.minecraft.resources.ResourceKey`
   - `net.minecraft.world.entity.npc.villager.VillagerProfession`
   - `net.minecraft.world.item.trading.MerchantOffer`
   - `net.minecraft.world.item.trading.ItemCost`
   - `net.minecraft.world.item.ItemStack`
   - `net.minecraft.world.item.Item`
   - `net.minecraft.world.item.Items`
   - `net.minecraft.server.level.ServerLevel`
   - `net.minecraft.util.RandomSource`
   - `java.util.List`
   - `java.util.Optional`
   - `java.util.function.Supplier`

3. Public final class `CustomTradeTables` with:

Static helper methods:
- `public static boolean hasCustomTrades(ResourceKey<VillagerProfession> profession)`: Returns true if profession is LIBRARIAN, BUTCHER, MASON, or CARTOGRAPHER. Use `VillagerProfession.LIBRARIAN.location()` etc. to compare.

- `public static List<MerchantOffer> getTradesFor(ResourceKey<VillagerProfession> profession, int level, ServerLevel serverLevel, RandomSource random)`: Dispatcher method that calls profession-specific trade getters. Returns empty list for now (placeholder).

Factory methods for trade creation (used by later plans):
- `public static MerchantOffer createSimpleTrade(Item costItem, int costCount, Item resultItem, int resultCount)`: Creates MerchantOffer with single input. Use `new ItemCost(costItem, costCount)`, `Optional.empty()` for second cost, `new ItemStack(resultItem, resultCount)`, uses=0, maxUses=Integer.MAX_VALUE, xp=0, priceMultiplier=0.05f.

- `public static MerchantOffer createTwoInputTrade(Item cost1Item, int cost1Count, Item cost2Item, int cost2Count, Item resultItem, int resultCount)`: Creates MerchantOffer with two inputs. Same pattern but with `Optional.of(new ItemCost(cost2Item, cost2Count))` for second cost.

- `public static MerchantOffer getVariantTrade(RandomSource random, Supplier<MerchantOffer> optionA, Supplier<MerchantOffer> optionB)`: Returns `random.nextBoolean() ? optionA.get() : optionB.get()` for 50/50 selection.

Private constructor to prevent instantiation.

Key details per CONTEXT.md:
- maxUses = Integer.MAX_VALUE (unlimited trades)
- xp = 0 (no XP gain, manual leveling in Phase 69)
- priceMultiplier = 0.05f (standard)
  </action>
  <verify>File compiles: `cd /mnt/c/home/code/thc && ./gradlew compileJava 2>&1 | tail -20`</verify>
  <done>CustomTradeTables.java exists with hasCustomTrades(), getTradesFor(), and factory methods</done>
</task>

<task type="auto">
  <name>Task 2: Create VillagerTradesMixin</name>
  <files>src/main/java/thc/mixin/VillagerTradesMixin.java, src/main/resources/thc.mixins.json</files>
  <action>
Create a new Java file `src/main/java/thc/mixin/VillagerTradesMixin.java` with:

1. Package `thc.mixin`

2. Required imports:
   - `net.minecraft.resources.ResourceKey`
   - `net.minecraft.server.level.ServerLevel`
   - `net.minecraft.world.entity.npc.villager.Villager`
   - `net.minecraft.world.entity.npc.villager.VillagerData`
   - `net.minecraft.world.entity.npc.villager.VillagerProfession`
   - `net.minecraft.world.item.trading.MerchantOffer`
   - `net.minecraft.world.item.trading.MerchantOffers`
   - `org.spongepowered.asm.mixin.Mixin`
   - `org.spongepowered.asm.mixin.Shadow`
   - `org.spongepowered.asm.mixin.injection.At`
   - `org.spongepowered.asm.mixin.injection.Inject`
   - `org.spongepowered.asm.mixin.injection.callback.CallbackInfo`
   - `thc.villager.CustomTradeTables`
   - `java.util.List`

3. Mixin class targeting `Villager.class`:

```java
@Mixin(Villager.class)
public abstract class VillagerTradesMixin {

    @Shadow public abstract VillagerData getVillagerData();
    @Shadow public abstract MerchantOffers getOffers();

    /**
     * Intercept trade generation to replace vanilla random pools with
     * THC deterministic trade tables for allowed professions.
     *
     * <p>This method is called when a villager gains a new level.
     * For custom professions (librarian, butcher, mason, cartographer),
     * we add our curated trades and skip vanilla generation.
     */
    @Inject(method = "updateTrades", at = @At("HEAD"), cancellable = true)
    private void thc$customTrades(CallbackInfo ci) {
        Villager self = (Villager)(Object)this;
        VillagerData data = self.getVillagerData();

        ResourceKey<VillagerProfession> profKey = data.profession().unwrapKey().orElse(null);
        if (profKey == null) return; // NONE profession, let vanilla handle

        int villagerLevel = data.level();

        // Check if this profession has custom trades
        if (!CustomTradeTables.hasCustomTrades(profKey)) {
            return; // Let vanilla handle non-overridden professions
        }

        // Get server level for registry access (needed for enchanted books)
        if (!(self.level() instanceof ServerLevel serverLevel)) {
            return; // Client side, skip
        }

        // Get custom trades for this level
        List<MerchantOffer> customOffers = CustomTradeTables.getTradesFor(
            profKey,
            villagerLevel,
            serverLevel,
            serverLevel.getRandom()
        );

        // Add custom trades to the villager's offers
        MerchantOffers offers = self.getOffers();
        offers.addAll(customOffers);

        ci.cancel(); // Skip vanilla trade generation
    }
}
```

Then update `src/main/resources/thc.mixins.json`:
- Add `"VillagerTradesMixin"` to the mixins array (after VillagerMixin)
  </action>
  <verify>Build succeeds: `cd /mnt/c/home/code/thc && ./gradlew build 2>&1 | tail -30`</verify>
  <done>VillagerTradesMixin registered and compiles, intercepts updateTrades() for custom professions</done>
</task>

</tasks>

<verification>
1. Build succeeds: `./gradlew build`
2. VillagerTradesMixin is registered in thc.mixins.json
3. CustomTradeTables.hasCustomTrades() returns true for allowed professions
</verification>

<success_criteria>
- CustomTradeTables.java exists with factory methods and hasCustomTrades() logic
- VillagerTradesMixin.java intercepts updateTrades() and calls CustomTradeTables
- Build passes without errors
- Foundation ready for trade content in subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/68-custom-trade-tables/68-01-SUMMARY.md`
</output>
