---
phase: 70-trade-cycling
plan: 01
type: execute
wave: 1
depends_on: ["68-01", "69-02"]
files_modified:
  - src/main/java/thc/villager/CustomTradeTables.java
  - src/main/kotlin/thc/villager/VillagerInteraction.kt
autonomous: true

must_haves:
  truths:
    - "Right-click with emerald at 0 XP rerolls current level trades"
    - "Earlier rank trades are preserved during cycling"
    - "Emerald is consumed on successful cycle"
    - "Cycling blocked (no emerald consumed) when trade pool has only 1 option"
    - "Success feedback: HAPPY_VILLAGER particles + VILLAGER_YES sound"
    - "Failure feedback: VILLAGER_NO sound (head shake)"
  artifacts:
    - path: "src/main/java/thc/villager/CustomTradeTables.java"
      provides: "getTradeCount() and getTradePoolSize() helper methods"
      contains: "getTradePoolSize"
    - path: "src/main/kotlin/thc/villager/VillagerInteraction.kt"
      provides: "Trade cycling logic integrated with 0 XP path"
      contains: "cycleCurrentLevelTrades"
  key_links:
    - from: "VillagerInteraction.kt"
      to: "CustomTradeTables"
      via: "getTradeCount(), getTradePoolSize(), getTradesFor() calls"
      pattern: "CustomTradeTables\\.(getTradeCount|getTradePoolSize|getTradesFor)"
---

<objective>
Implement trade cycling: right-click villager with emerald at 0 XP to reroll current-level trades.

Purpose: VCYC-01/02/03 — Allow players to search for specific trades within deterministic trade pools by paying emeralds
Output: Extended CustomTradeTables with count/pool methods, VillagerInteraction with cycling logic
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/70-trade-cycling/70-CONTEXT.md
@.planning/phases/70-trade-cycling/70-RESEARCH.md
@.planning/phases/68-custom-trade-tables/68-01-SUMMARY.md
@.planning/phases/69-manual-leveling/69-02-SUMMARY.md
@src/main/java/thc/villager/CustomTradeTables.java
@src/main/kotlin/thc/villager/VillagerInteraction.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trade count and pool size methods to CustomTradeTables</name>
  <files>src/main/java/thc/villager/CustomTradeTables.java</files>
  <action>
Add two new public static methods to CustomTradeTables.java:

1. `getTradeCount(ResourceKey<VillagerProfession> profession, int level)`:
   Returns the number of trades for a profession at a specific level.
   Based on Phase 68 trade structure:
   - LIBRARIAN: levels 1-4 = 2 trades, level 5 = 1 trade
   - BUTCHER: levels 1-3 = 2 trades, levels 4-5 = 1 trade
   - MASON: level 1 = 4 trades, levels 2-3 = 2 trades, levels 4-5 = 1 trade
   - CARTOGRAPHER: levels 1-2 = 3 trades, level 3 = 2 trades, levels 4-5 = 1 trade
   - Return 0 for unknown profession or level

2. `getTradePoolSize(ResourceKey<VillagerProfession> profession, int level)`:
   Returns effective pool size for cycling (number of distinct options).
   Pool > 1 means cycling produces different results (50/50 variants exist).
   Pool = 1 means deterministic (cycling should be blocked).
   - LIBRARIAN: return 2 (all levels have 50/50 variants)
   - MASON: return level >= 2 ? 2 : 1 (level 1 deterministic, 2+ have variants)
   - BUTCHER: return 1 (fully deterministic)
   - CARTOGRAPHER: return 1 (fully deterministic)

Use switch expressions for clean implementation. Match profession via `profession.location().equals(VillagerProfession.X.location())` pattern established in hasCustomTrades().
  </action>
  <verify>File compiles: `cd /mnt/c/home/code/thc && ./gradlew compileJava --quiet 2>&1 | tail -10`</verify>
  <done>CustomTradeTables has getTradeCount() and getTradePoolSize() methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement trade cycling in VillagerInteraction.kt</name>
  <files>src/main/kotlin/thc/villager/VillagerInteraction.kt</files>
  <action>
Extend the existing VillagerInteraction object to handle trade cycling when XP == 0.

Phase 69's handleLevelUp already returns PASS when currentXp == 0. Modify this path to handle cycling instead:

1. In the 0 XP path (where it currently returns PASS), add cycling logic:
   - Get profession key from villager.villagerData.profession().unwrapKey()
   - Check CustomTradeTables.hasCustomTrades(profKey) — return PASS if false
   - Get pool size: CustomTradeTables.getTradePoolSize(profKey, currentLevel)
   - If poolSize <= 1: play failure effects (VILLAGER_NO sound), return SUCCESS (blocks GUI, no emerald consumed)
   - Otherwise: proceed with cycling

2. Cycling logic:
   - Consume emerald: stack.shrink(1)
   - Call cycleCurrentLevelTrades(villager, profKey, currentLevel, level)
   - Play success effects (HAPPY_VILLAGER particles + VILLAGER_YES sound)
   - Return SUCCESS

3. Add private function `cycleCurrentLevelTrades(villager, profKey, currentLevel, serverLevel)`:
   - Calculate trades before current level: sum of CustomTradeTables.getTradeCount(profKey, lvl) for lvl in 1 until currentLevel
   - Remove current level trades from villager.offers (remove from end until offers.size == tradesBeforeCurrentLevel)
   - Generate new trades: CustomTradeTables.getTradesFor(profKey, currentLevel, serverLevel, serverLevel.random)
   - Add new trades: offers.addAll(newTrades)

4. Add helper functions for feedback effects:
   - playSuccessEffects: HAPPY_VILLAGER particles (10 count, spread 0.5) + VILLAGER_YES sound
   - playFailureEffects: VILLAGER_NO sound only

Required additional imports:
- net.minecraft.resources.ResourceKey
- net.minecraft.world.entity.npc.villager.VillagerProfession (if not already)

Keep the existing level-up logic intact. The 0 XP path that previously returned PASS now handles cycling.
  </action>
  <verify>Build succeeds: `cd /mnt/c/home/code/thc && ./gradlew build --quiet 2>&1 | tail -10`</verify>
  <done>VillagerInteraction handles cycling at 0 XP with proper pool size checking and trade replacement</done>
</task>

<task type="auto">
  <name>Task 3: Verify integration</name>
  <files></files>
  <action>
Verify complete integration:
1. Build succeeds with no errors
2. CustomTradeTables has both new methods
3. VillagerInteraction imports and uses CustomTradeTables
4. Cycling logic is wired to 0 XP path
  </action>
  <verify>
`./gradlew build --quiet` succeeds AND
`grep -l "getTradePoolSize" src/main/java/thc/villager/CustomTradeTables.java` returns file AND
`grep -l "cycleCurrentLevelTrades" src/main/kotlin/thc/villager/VillagerInteraction.kt` returns file
  </verify>
  <done>Full build passes with trade cycling integrated</done>
</task>

</tasks>

<verification>
1. Build passes: `./gradlew build`
2. Pool size method exists: grep "getTradePoolSize" src/main/java/thc/villager/CustomTradeTables.java
3. Trade count method exists: grep "getTradeCount" src/main/java/thc/villager/CustomTradeTables.java
4. Cycling function exists: grep "cycleCurrentLevelTrades" src/main/kotlin/thc/villager/VillagerInteraction.kt
5. Sound effects used: grep "VILLAGER_NO\|VILLAGER_YES" src/main/kotlin/thc/villager/VillagerInteraction.kt
</verification>

<success_criteria>
- CustomTradeTables.getTradeCount() returns correct counts per profession/level
- CustomTradeTables.getTradePoolSize() returns 2 for librarian (all), mason (2+), 1 for others
- Cycling at 0 XP removes current-level trades and regenerates with fresh random
- Earlier level trades preserved (proper index calculation)
- Emerald consumed only on successful cycle
- Pool size 1 blocks cycling (VILLAGER_NO sound, no emerald consumed)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/70-trade-cycling/70-01-SUMMARY.md`
</output>
