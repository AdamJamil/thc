---
phase: 72-core-downed-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/THCAttachments.java
  - src/main/java/thc/downed/DownedState.java
  - src/main/java/thc/downed/DownedManager.java
  - src/main/java/thc/mixin/ServerPlayerMixin.java
  - src/main/kotlin/thc/THC.kt
autonomous: true

must_haves:
  truths:
    - "Player at 0 HP enters spectator mode instead of dying"
    - "Downed player position is tracked for tether and revival"
    - "Downed player is teleported back if more than 50 blocks from downed location"
  artifacts:
    - path: "src/main/java/thc/THCAttachments.java"
      provides: "DOWNED_LOCATION attachment"
      contains: "DOWNED_LOCATION"
    - path: "src/main/java/thc/downed/DownedState.java"
      provides: "State accessor for downed status"
      exports: ["getDownedLocation", "setDownedLocation", "isDowned", "clearDowned"]
    - path: "src/main/java/thc/downed/DownedManager.java"
      provides: "Death interception event registration"
      exports: ["register"]
    - path: "src/main/java/thc/mixin/ServerPlayerMixin.java"
      provides: "50-block tether enforcement in tick"
      contains: "thc$enforceTether"
  key_links:
    - from: "src/main/java/thc/downed/DownedManager.java"
      to: "ServerLivingEntityEvents.ALLOW_DEATH"
      via: "Fabric API event registration"
      pattern: "ALLOW_DEATH\\.register"
    - from: "src/main/java/thc/downed/DownedManager.java"
      to: "src/main/java/thc/downed/DownedState.java"
      via: "setDownedLocation call"
      pattern: "DownedState\\.setDownedLocation"
    - from: "src/main/java/thc/mixin/ServerPlayerMixin.java"
      to: "src/main/java/thc/downed/DownedState.java"
      via: "getDownedLocation call for tether check"
      pattern: "DownedState\\.getDownedLocation"
---

<objective>
Implement the core downed state system that intercepts player death, switches to spectator mode, and enforces a 50-block tether to the downed location.

Purpose: Foundation for v3.0 revival system - players enter spectator mode instead of dying, allowing teammates to revive them.
Output: Working downed state with death interception, spectator mode switch, and tether enforcement.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/72-core-downed-state/72-CONTEXT.md
@.planning/phases/72-core-downed-state/72-RESEARCH.md

# Existing patterns to follow:
@src/main/java/thc/THCAttachments.java
@src/main/java/thc/buckler/BucklerState.java
@src/main/java/thc/mixin/ServerPlayerMixin.java
@src/main/kotlin/thc/THC.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DOWNED_LOCATION attachment and DownedState accessor</name>
  <files>
    src/main/java/thc/THCAttachments.java
    src/main/java/thc/downed/DownedState.java
  </files>
  <action>
1. In THCAttachments.java, add new non-persistent Vec3 attachment:
   ```java
   import net.minecraft.world.phys.Vec3;

   /**
    * Tracks the location where a player was downed (for tether enforcement and revival).
    * Non-persistent - downed state should not survive server restart.
    * Null when player is not downed.
    */
   public static final AttachmentType<Vec3> DOWNED_LOCATION = AttachmentRegistry.create(
       Identifier.fromNamespaceAndPath("thc", "downed_location"),
       builder -> builder.initializer(() -> null)
   );
   ```

2. Create new package `thc/downed/` and add DownedState.java accessor class:
   - Follow BucklerState.java pattern exactly
   - Private constructor, static methods only
   - Methods: getDownedLocation, setDownedLocation, isDowned, clearDowned
   - isDowned returns true if location is set AND player is in spectator mode
   - Use ServerPlayer (not LivingEntity) since downed state is player-only
  </action>
  <verify>
    Run `./gradlew compileJava` - should compile without errors
  </verify>
  <done>
    DOWNED_LOCATION attachment exists in THCAttachments, DownedState accessor class created with get/set/isDowned/clear methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement death interception and tether enforcement</name>
  <files>
    src/main/java/thc/downed/DownedManager.java
    src/main/java/thc/mixin/ServerPlayerMixin.java
    src/main/kotlin/thc/THC.kt
  </files>
  <action>
1. Create DownedManager.java in thc/downed/ package:
   ```java
   package thc.downed;

   import net.fabricmc.fabric.api.entity.event.v1.ServerLivingEntityEvents;
   import net.minecraft.server.level.ServerPlayer;
   import net.minecraft.world.level.GameType;
   import net.minecraft.world.phys.Vec3;

   public final class DownedManager {
       private DownedManager() {}

       public static void register() {
           ServerLivingEntityEvents.ALLOW_DEATH.register((entity, damageSource, damageAmount) -> {
               if (!(entity instanceof ServerPlayer player)) {
                   return true; // Allow non-player deaths
               }

               // Already downed - shouldn't happen but be safe
               if (DownedState.isDowned(player)) {
                   return false;
               }

               // Store location BEFORE switching mode (exact death position)
               Vec3 deathLocation = player.position();

               // Switch to spectator (makes player invulnerable, invisible to mobs)
               player.setGameMode(GameType.SPECTATOR);

               // Store downed location in attachment
               DownedState.setDownedLocation(player, deathLocation);

               // Cancel death
               return false;
           });
       }
   }
   ```

2. Add tether enforcement to ServerPlayerMixin.java:
   - Add import for DownedState
   - Add new @Inject on tick method at HEAD (can use existing tick injection or add new one):
   ```java
   @Inject(method = "tick", at = @At("HEAD"))
   private void thc$enforceTether(CallbackInfo ci) {
       ServerPlayer self = (ServerPlayer) (Object) this;
       Vec3 downedLoc = DownedState.getDownedLocation(self);

       // Only enforce tether for downed players
       if (downedLoc == null) {
           return;
       }

       // 50 block tether radius (squared to avoid sqrt)
       double distSq = self.position().distanceToSqr(downedLoc);
       if (distSq > 2500.0) { // 50 * 50 = 2500
           self.teleportTo(downedLoc.x, downedLoc.y, downedLoc.z);
       }
   }
   ```
   Note: If existing tick injection exists, you can add tether logic to it. If multiple tick injections are problematic, merge the logic.

3. Register DownedManager in THC.kt onInitialize():
   - Add import: `import thc.downed.DownedManager`
   - Add registration call: `DownedManager.register()` (place near other manager registrations)
  </action>
  <verify>
    Run `./gradlew build` - should compile and build successfully
  </verify>
  <done>
    Death event intercepted, player switches to spectator mode, location stored, 50-block tether enforced via tick hook
  </done>
</task>

</tasks>

<verification>
1. `./gradlew build` passes
2. Code inspection confirms:
   - DOWNED_LOCATION attachment in THCAttachments
   - DownedState accessor with get/set/isDowned/clear methods
   - DownedManager registers ALLOW_DEATH event
   - ServerPlayerMixin has tether enforcement in tick
   - THC.kt calls DownedManager.register()
</verification>

<success_criteria>
- Player death intercepted and converted to spectator mode switch
- Downed location tracked in non-persistent attachment
- 50-block tether enforced (teleport back if exceeded)
- Spectator mode provides invulnerability and mob AI exclusion (vanilla behavior)
- All code compiles and builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/72-core-downed-state/72-01-SUMMARY.md`
</output>
