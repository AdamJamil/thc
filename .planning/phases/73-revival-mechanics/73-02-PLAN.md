---
phase: 73-revival-mechanics
plan: 02
type: execute
wave: 2
depends_on: ["73-01"]
files_modified:
  - src/main/kotlin/thc/THC.kt
  - src/main/java/thc/downed/DownedState.java
autonomous: true

must_haves:
  truths:
    - "Revived player is set to survival mode"
    - "Revived player is teleported to their downed location"
    - "Revived player has 50% of max HP"
    - "Revived player has 6 hunger (not 0)"
    - "Green particles play on successful revival"
  artifacts:
    - path: "src/main/kotlin/thc/THC.kt"
      provides: "Revival completion logic in tick processor"
      contains: "completeRevival"
    - path: "src/main/java/thc/downed/DownedState.java"
      provides: "clearDowned method clears both location and progress"
      exports: ["clearDowned"]
  key_links:
    - from: "src/main/kotlin/thc/THC.kt"
      to: "src/main/java/thc/downed/RevivalState.java"
      via: "Check if progress >= 1.0 for completion"
      pattern: "RevivalState\\.getProgress.*>= 1\\.0"
    - from: "src/main/kotlin/thc/THC.kt"
      to: "src/main/java/thc/downed/DownedState.java"
      via: "Clear downed state on revival"
      pattern: "DownedState\\.clearDowned"
    - from: "src/main/kotlin/thc/THC.kt"
      to: "ParticleTypes.HAPPY_VILLAGER"
      via: "Green particles on completion"
      pattern: "ParticleTypes\\.HAPPY_VILLAGER"
---

<objective>
Complete the revival mechanic: when progress reaches 100%, restore the downed player to survival mode with specified state (50% HP, 6 hunger) and play green particles.

Purpose: Finishes the revival system - players can now be fully revived after accumulating progress.
Output: Working revival completion with player state restoration and visual feedback.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/73-revival-mechanics/73-CONTEXT.md
@.planning/phases/73-revival-mechanics/73-RESEARCH.md

# Phase 73-01 adds RevivalState and processRevival tick processor
@src/main/java/thc/downed/DownedState.java
@src/main/java/thc/downed/RevivalState.java
@src/main/kotlin/thc/THC.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update DownedState.clearDowned to also clear revival progress</name>
  <files>
    src/main/java/thc/downed/DownedState.java
  </files>
  <action>
1. Add import for RevivalState at top of DownedState.java (if in same package, not needed)

2. Update the clearDowned method to also clear revival progress:
   ```java
   public static void clearDowned(ServerPlayer player) {
       // Clear downed location
       target(player).setAttached(THCAttachments.DOWNED_LOCATION, null);
       // Also clear revival progress
       RevivalState.clearProgress(player);
   }
   ```

This ensures revival progress is reset when a player is no longer downed.
  </action>
  <verify>
    Run `./gradlew compileJava` - should compile without errors
  </verify>
  <done>
    clearDowned clears both DOWNED_LOCATION and REVIVAL_PROGRESS
  </done>
</task>

<task type="auto">
  <name>Task 2: Add revival completion logic to tick processor</name>
  <files>
    src/main/kotlin/thc/THC.kt
  </files>
  <action>
1. Add import for particles at top of THC.kt:
   ```kotlin
   import net.minecraft.core.particles.ParticleTypes
   import net.minecraft.world.level.GameType
   ```

2. Add a private function for completing revival:
   ```kotlin
   private fun completeRevival(player: net.minecraft.server.level.ServerPlayer, downedLocation: net.minecraft.world.phys.Vec3) {
       // Clear downed state (also clears revival progress)
       DownedState.clearDowned(player)

       // Restore to survival mode
       player.setGameMode(GameType.SURVIVAL)

       // Teleport to downed location
       player.teleportTo(downedLocation.x, downedLocation.y, downedLocation.z)

       // Set health to 50% of max
       val maxHealth = player.maxHealth
       player.health = maxHealth * 0.5f

       // Set food level to 6 (CONTEXT.md override: not 0)
       player.foodData.foodLevel = 6

       // Spawn green particles (HAPPY_VILLAGER)
       val level = player.serverLevel()
       level.sendParticles(
           ParticleTypes.HAPPY_VILLAGER,
           downedLocation.x,
           downedLocation.y + 1.0,
           downedLocation.z,
           30,           // count
           0.5, 0.5, 0.5, // spread (x, y, z)
           0.0           // speed
       )
   }
   ```

3. Update processRevival to check for completion AFTER accumulating progress:
   At the end of processRevival (after the nested for loops), add a completion check pass:
   ```kotlin
   // Check for revival completion (separate pass to avoid concurrent modification)
   for (downed in downedPlayers) {
       if (RevivalState.getProgress(downed) >= 1.0) {
           val downedLoc = DownedState.getDownedLocation(downed)
           if (downedLoc != null) {
               completeRevival(downed, downedLoc)
           }
       }
   }
   ```

The full processRevival function should now look like:
```kotlin
private fun processRevival(server: MinecraftServer) {
    val players = server.playerList.players

    // Find all downed players first
    val downedPlayers = players.filter { DownedState.isDowned(it) }
    if (downedPlayers.isEmpty()) return

    // For each alive player who is sneaking, check proximity to downed players
    for (reviver in players) {
        // Must be alive (not downed) and sneaking
        if (DownedState.isDowned(reviver)) continue
        if (!reviver.isShiftKeyDown) continue

        // Determine progress rate based on class
        val playerClass = ClassManager.getClass(reviver)
        val progressRate = if (playerClass == PlayerClass.SUPPORT) {
            1.0 / 100.0  // 100 ticks = 5 seconds
        } else {
            0.5 / 100.0  // 200 ticks = 10 seconds
        }

        // Check each downed player
        for (downed in downedPlayers) {
            val downedLoc = DownedState.getDownedLocation(downed) ?: continue

            // 2 block radius = 4.0 squared distance
            val distSq = reviver.position().distanceToSqr(downedLoc)
            if (distSq > 4.0) continue

            // Accumulate progress on the downed player
            RevivalState.addProgress(downed, progressRate)
        }
    }

    // Check for revival completion (separate pass to avoid concurrent modification)
    for (downed in downedPlayers) {
        if (RevivalState.getProgress(downed) >= 1.0) {
            val downedLoc = DownedState.getDownedLocation(downed)
            if (downedLoc != null) {
                completeRevival(downed, downedLoc)
            }
        }
    }
}
```
  </action>
  <verify>
    Run `./gradlew build` - should compile and build successfully
  </verify>
  <done>
    Revival completion triggers at 100% progress, restoring survival mode, teleporting to downed location, setting 50% HP / 6 hunger, spawning green particles
  </done>
</task>

</tasks>

<verification>
1. `./gradlew build` passes
2. Code inspection confirms:
   - DownedState.clearDowned also calls RevivalState.clearProgress
   - completeRevival function exists in THC.kt
   - Progress check >= 1.0 triggers completion
   - GameType.SURVIVAL restored
   - Teleport to downed location
   - Health set to maxHealth * 0.5f
   - Food level set to 6 (not 0)
   - ParticleTypes.HAPPY_VILLAGER spawned (30 particles)
</verification>

<success_criteria>
- Revival completion triggers when progress >= 1.0
- Player switched from spectator to survival mode
- Player teleported to downed location (exact death position)
- Player health set to 50% of max
- Player hunger set to 6 (CONTEXT.md override from requirements)
- Green particles (HAPPY_VILLAGER) spawned at revival location
- Downed state cleared (location and progress)
- All code compiles and builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/73-revival-mechanics/73-02-SUMMARY.md`
</output>
