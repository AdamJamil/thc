---
phase: 74-revival-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/thc/network/RevivalStatePayload.java
  - src/main/java/thc/network/RevivalSync.java
  - src/main/kotlin/thc/THC.kt
  - src/client/java/thc/client/RevivalClientState.java
  - src/client/kotlin/thc/client/RevivalProgressRenderer.kt
  - src/client/kotlin/thc/THCClient.kt
autonomous: true

must_haves:
  truths:
    - "Radial progress ring appears around cursor when looking at downed location within 2 blocks"
    - "Empty ring shows at 0% progress"
    - "Filled ring fills radially clockwise from 12 o'clock as progress increases"
    - "Ring disappears when not looking at downed location or revival completes"
  artifacts:
    - path: "src/main/java/thc/network/RevivalStatePayload.java"
      provides: "Network payload for revival state sync"
      contains: "RevivalStatePayload"
    - path: "src/main/java/thc/network/RevivalSync.java"
      provides: "Server-to-client revival state synchronization"
      exports: ["sync"]
    - path: "src/client/java/thc/client/RevivalClientState.java"
      provides: "Client-side cache of revival state"
      exports: ["update", "getProgress", "getDownedLocation", "getDownedUUID"]
    - path: "src/client/kotlin/thc/client/RevivalProgressRenderer.kt"
      provides: "HUD renderer for radial progress ring"
      exports: ["render"]
  key_links:
    - from: "src/main/kotlin/thc/THC.kt"
      to: "src/main/java/thc/network/RevivalSync.java"
      via: "Sync revival state each tick"
      pattern: "RevivalSync\\.sync"
    - from: "src/client/kotlin/thc/THCClient.kt"
      to: "src/main/java/thc/network/RevivalStatePayload.java"
      via: "Register payload receiver"
      pattern: "RevivalStatePayload\\.TYPE"
    - from: "src/client/kotlin/thc/client/RevivalProgressRenderer.kt"
      to: "src/client/java/thc/client/RevivalClientState.java"
      via: "Read progress for rendering"
      pattern: "RevivalClientState\\.getProgress"
---

<objective>
Implement the revival progress UI: a radial progress ring centered on the cursor that shows revival progress when looking at a downed player within 2 blocks.

Purpose: Visual feedback for revival mechanic - revivers need to see how much progress they've made.
Output: Working radial progress ring using existing textures, synced from server state.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/74-revival-ui/74-CONTEXT.md
@.planning/phases/74-revival-ui/74-RESEARCH.md

# Existing patterns to follow:
@src/main/java/thc/network/BucklerStatePayload.java
@src/main/java/thc/network/BucklerSync.java
@src/client/java/thc/client/BucklerClientState.java
@src/client/kotlin/thc/client/BucklerHudRenderer.kt
@src/client/kotlin/thc/THCClient.kt
@src/main/kotlin/thc/THC.kt

# Phase 72-73 artifacts (downed state + revival progress):
@src/main/java/thc/downed/DownedState.java
@src/main/java/thc/downed/RevivalState.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add revival state sync (server to client)</name>
  <files>
    src/main/java/thc/network/RevivalStatePayload.java
    src/main/java/thc/network/RevivalSync.java
    src/main/kotlin/thc/THC.kt
  </files>
  <action>
1. Create RevivalStatePayload.java following BucklerStatePayload pattern exactly:
   ```java
   package thc.network;

   import net.minecraft.network.RegistryFriendlyByteBuf;
   import net.minecraft.network.codec.StreamCodec;
   import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
   import net.minecraft.resources.Identifier;
   import java.util.UUID;

   /**
    * Syncs revival state to client for HUD rendering.
    * Sent to revivers who are looking at a downed location.
    */
   public record RevivalStatePayload(
       UUID downedPlayerUUID,     // UUID of downed player being revived
       double downedX,            // Downed location X
       double downedY,            // Downed location Y
       double downedZ,            // Downed location Z
       double progress            // Revival progress 0.0 to 1.0
   ) implements CustomPacketPayload {
       public static final Type<RevivalStatePayload> TYPE =
           new CustomPacketPayload.Type<>(Identifier.fromNamespaceAndPath("thc", "revival_state"));
       public static final StreamCodec<RegistryFriendlyByteBuf, RevivalStatePayload> STREAM_CODEC =
           StreamCodec.ofMember(RevivalStatePayload::write, RevivalStatePayload::new);

       // "Clear" payload - no active revival target
       public static final RevivalStatePayload CLEAR = new RevivalStatePayload(
           new UUID(0, 0), 0.0, 0.0, 0.0, 0.0
       );

       public RevivalStatePayload(RegistryFriendlyByteBuf buf) {
           this(buf.readUUID(), buf.readDouble(), buf.readDouble(), buf.readDouble(), buf.readDouble());
       }

       private void write(RegistryFriendlyByteBuf buf) {
           buf.writeUUID(this.downedPlayerUUID);
           buf.writeDouble(this.downedX);
           buf.writeDouble(this.downedY);
           buf.writeDouble(this.downedZ);
           buf.writeDouble(this.progress);
       }

       public boolean isClear() {
           return downedPlayerUUID.getMostSignificantBits() == 0
               && downedPlayerUUID.getLeastSignificantBits() == 0;
       }

       @Override
       public Type<? extends CustomPacketPayload> type() {
           return TYPE;
       }
   }
   ```

2. Create RevivalSync.java following BucklerSync pattern:
   ```java
   package thc.network;

   import java.util.HashMap;
   import java.util.Map;
   import java.util.UUID;
   import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
   import net.minecraft.server.level.ServerPlayer;
   import net.minecraft.world.phys.Vec3;
   import thc.downed.DownedState;
   import thc.downed.RevivalState;

   /**
    * Syncs revival state to clients for HUD rendering.
    * Only sends updates when state changes (delta sync).
    */
   public final class RevivalSync {
       private static final Map<UUID, RevivalSyncState> LAST_SENT = new HashMap<>();

       private RevivalSync() {}

       /**
        * Sync revival state for a potential reviver.
        * Finds the closest downed player within 2 blocks that the player is looking at.
        */
       public static void sync(ServerPlayer player, Iterable<ServerPlayer> allPlayers) {
           // Don't sync to downed players
           if (DownedState.isDowned(player)) {
               sendIfChanged(player, RevivalSyncState.CLEAR);
               return;
           }

           // Find closest downed player within 2 blocks that player is looking at
           RevivalSyncState target = findLookTarget(player, allPlayers);
           sendIfChanged(player, target);
       }

       public static void clear(ServerPlayer player) {
           LAST_SENT.remove(player.getUUID());
       }

       private static void sendIfChanged(ServerPlayer player, RevivalSyncState current) {
           RevivalSyncState previous = LAST_SENT.get(player.getUUID());
           if (current.equals(previous)) {
               return;
           }
           LAST_SENT.put(player.getUUID(), current);

           if (current == RevivalSyncState.CLEAR) {
               ServerPlayNetworking.send(player, RevivalStatePayload.CLEAR);
           } else {
               ServerPlayNetworking.send(player, new RevivalStatePayload(
                   current.downedUUID(),
                   current.downedX(),
                   current.downedY(),
                   current.downedZ(),
                   current.progress()
               ));
           }
       }

       private static RevivalSyncState findLookTarget(ServerPlayer player, Iterable<ServerPlayer> allPlayers) {
           Vec3 eyePos = player.getEyePosition();
           Vec3 lookVec = player.getLookAngle();

           RevivalSyncState closest = RevivalSyncState.CLEAR;
           double closestDistSq = Double.MAX_VALUE;

           for (ServerPlayer other : allPlayers) {
               if (!DownedState.isDowned(other)) continue;

               Vec3 downedLoc = DownedState.getDownedLocation(other);
               if (downedLoc == null) continue;

               // Check if within 2 blocks (squared distance = 4.0)
               double distSq = eyePos.distanceToSqr(downedLoc);
               if (distSq > 4.0) continue;

               // Check if player is roughly looking at the downed location
               // Use a generous cone (60 degree half-angle = cos(60) = 0.5)
               Vec3 toTarget = downedLoc.subtract(eyePos).normalize();
               double dot = lookVec.dot(toTarget);
               if (dot < 0.5) continue;  // Not looking toward target

               // Track closest valid target
               if (distSq < closestDistSq) {
                   closestDistSq = distSq;
                   double progress = RevivalState.getProgress(other);
                   closest = new RevivalSyncState(
                       other.getUUID(),
                       downedLoc.x,
                       downedLoc.y,
                       downedLoc.z,
                       progress
                   );
               }
           }

           return closest;
       }

       private record RevivalSyncState(UUID downedUUID, double downedX, double downedY, double downedZ, double progress) {
           static final RevivalSyncState CLEAR = new RevivalSyncState(new UUID(0, 0), 0.0, 0.0, 0.0, 0.0);
       }
   }
   ```

3. Register payload and add sync call in THC.kt:
   - Add import: `import thc.network.RevivalSync`
   - In onInitialize(), add payload registration near BucklerStatePayload registration:
     ```kotlin
     PayloadTypeRegistry.playS2C().register(
         RevivalStatePayload.TYPE,
         RevivalStatePayload.STREAM_CODEC
     )
     ```
   - In the END_SERVER_TICK handler, after processRevival call, add revival sync:
     ```kotlin
     // Sync revival state to all players for HUD rendering
     val players = server.playerList.players
     for (player in players) {
         RevivalSync.sync(player, players)
     }
     ```
  </action>
  <verify>
    Run `./gradlew compileJava compileKotlin` - should compile without errors
  </verify>
  <done>
    RevivalStatePayload created, RevivalSync syncs state to clients, THC.kt registers payload and calls sync each tick
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client-side renderer with radial progress fill</name>
  <files>
    src/client/java/thc/client/RevivalClientState.java
    src/client/kotlin/thc/client/RevivalProgressRenderer.kt
    src/client/kotlin/thc/THCClient.kt
  </files>
  <action>
1. Create RevivalClientState.java following BucklerClientState pattern:
   ```java
   package thc.client;

   import java.util.UUID;

   /**
    * Client-side cache of revival state for HUD rendering.
    */
   public final class RevivalClientState {
       private static UUID downedUUID = null;
       private static double downedX;
       private static double downedY;
       private static double downedZ;
       private static double progress;

       private RevivalClientState() {}

       public static void update(UUID uuid, double x, double y, double z, double newProgress) {
           if (uuid.getMostSignificantBits() == 0 && uuid.getLeastSignificantBits() == 0) {
               // Clear state
               downedUUID = null;
               progress = 0.0;
           } else {
               downedUUID = uuid;
               downedX = x;
               downedY = y;
               downedZ = z;
               progress = newProgress;
           }
       }

       public static boolean hasTarget() {
           return downedUUID != null;
       }

       public static UUID getDownedUUID() {
           return downedUUID;
       }

       public static double getDownedX() {
           return downedX;
       }

       public static double getDownedY() {
           return downedY;
       }

       public static double getDownedZ() {
           return downedZ;
       }

       public static double getProgress() {
           return progress;
       }
   }
   ```

2. Create RevivalProgressRenderer.kt with radial fill rendering:
   ```kotlin
   package thc.client

   import com.mojang.blaze3d.vertex.BufferUploader
   import com.mojang.blaze3d.vertex.DefaultVertexFormat
   import com.mojang.blaze3d.vertex.Tesselator
   import com.mojang.blaze3d.vertex.VertexFormat
   import net.minecraft.client.Minecraft
   import net.minecraft.client.gui.GuiGraphics
   import net.minecraft.client.renderer.RenderPipelines
   import net.minecraft.resources.Identifier
   import kotlin.math.PI
   import kotlin.math.cos
   import kotlin.math.sin

   /**
    * Renders radial progress ring around cursor when looking at downed player.
    * Empty ring shows at 0%, filled ring fills clockwise from 12 o'clock.
    */
   object RevivalProgressRenderer {
       val REVIVAL_PROGRESS_ID: Identifier = Identifier.fromNamespaceAndPath("thc", "revival_progress")

       private val EMPTY_TEXTURE = Identifier.fromNamespaceAndPath("thc", "textures/item/revival_progress_empty.png")
       private val FULL_TEXTURE = Identifier.fromNamespaceAndPath("thc", "textures/item/revival_progress_full.png")

       // Texture is 32x32, render at 1:1 scale (user can tune this)
       private const val TEXTURE_SIZE = 32
       private const val RENDER_SIZE = 32
       private const val HALF_SIZE = RENDER_SIZE / 2

       fun render(guiGraphics: GuiGraphics) {
           val client = Minecraft.getInstance()
           if (client.options.hideGui || client.player?.isSpectator == true) {
               return
           }

           // Check if we have a revival target
           if (!RevivalClientState.hasTarget()) {
               return
           }

           val progress = RevivalClientState.getProgress()

           val centerX = guiGraphics.guiWidth() / 2
           val centerY = guiGraphics.guiHeight() / 2

           // Always render empty ring as background
           guiGraphics.blit(
               RenderPipelines.GUI_TEXTURED,
               EMPTY_TEXTURE,
               centerX - HALF_SIZE,
               centerY - HALF_SIZE,
               0.0f,
               0.0f,
               RENDER_SIZE,
               RENDER_SIZE,
               TEXTURE_SIZE,
               TEXTURE_SIZE
           )

           // Render filled ring as radial pie if progress > 0
           if (progress > 0.0) {
               renderRadialFill(guiGraphics, centerX, centerY, progress.toFloat())
           }
       }

       /**
        * Renders the filled texture as a pie/fan shape based on progress.
        * Uses triangle fan from center, clockwise from 12 o'clock.
        */
       private fun renderRadialFill(guiGraphics: GuiGraphics, centerX: Int, centerY: Int, progress: Float) {
           val matrices = guiGraphics.pose()
           matrices.pushMatrix()

           // Translate to screen center
           matrices.translate(centerX.toFloat(), centerY.toFloat(), 0f)

           // Bind the filled texture using RenderSystem
           com.mojang.blaze3d.systems.RenderSystem.setShaderTexture(0, FULL_TEXTURE)
           com.mojang.blaze3d.systems.RenderSystem.setShader { com.mojang.blaze3d.shaders.CoreShaders.POSITION_TEX }
           com.mojang.blaze3d.systems.RenderSystem.enableBlend()

           val tesselator = Tesselator.getInstance()
           val builder = tesselator.begin(VertexFormat.Mode.TRIANGLE_FAN, DefaultVertexFormat.POSITION_TEX)
           val matrix = matrices.last().pose()

           // Start angle: -PI/2 (12 o'clock, pointing up)
           // End angle: startAngle + progress * 2*PI (clockwise)
           val startAngle = -PI.toFloat() / 2f
           val endAngle = startAngle + (progress * 2f * PI.toFloat())

           // Number of segments (more segments = smoother arc)
           val segments = (progress * 32).toInt().coerceAtLeast(3)

           // Center vertex of the fan
           builder.addVertex(matrix, 0f, 0f, 0f).setUv(0.5f, 0.5f)

           // Arc vertices clockwise from 12 o'clock
           for (i in 0..segments) {
               val angle = startAngle + (endAngle - startAngle) * i / segments
               val x = HALF_SIZE * cos(angle)
               val y = HALF_SIZE * sin(angle)

               // UV coordinates: map angle to texture space
               // Texture center is (0.5, 0.5), radius maps to edge
               val u = 0.5f + 0.5f * cos(angle)
               val v = 0.5f + 0.5f * sin(angle)

               builder.addVertex(matrix, x, y, 0f).setUv(u, v)
           }

           BufferUploader.drawWithShader(builder.buildOrThrow())

           com.mojang.blaze3d.systems.RenderSystem.disableBlend()
           matrices.popMatrix()
       }
   }
   ```

3. Register receiver and HUD element in THCClient.kt:
   - Add imports:
     ```kotlin
     import thc.client.RevivalClientState
     import thc.client.RevivalProgressRenderer
     import thc.network.RevivalStatePayload
     ```
   - Register payload receiver after BucklerStatePayload receiver:
     ```kotlin
     ClientPlayNetworking.registerGlobalReceiver(RevivalStatePayload.TYPE) { payload, context ->
         context.client().execute {
             RevivalClientState.update(
                 payload.downedPlayerUUID(),
                 payload.downedX(),
                 payload.downedY(),
                 payload.downedZ(),
                 payload.progress()
             )
         }
     }
     ```
   - Register HUD element BEFORE crosshair (so it renders behind):
     ```kotlin
     HudElementRegistry.attachElementBefore(VanillaHudElements.CROSSHAIR, RevivalProgressRenderer.REVIVAL_PROGRESS_ID) { guiGraphics, _ ->
         RevivalProgressRenderer.render(guiGraphics)
     }
     ```
  </action>
  <verify>
    Run `./gradlew build` - should compile and build successfully
  </verify>
  <done>
    RevivalClientState caches server state, RevivalProgressRenderer draws radial progress ring, THCClient registers receiver and HUD element
  </done>
</task>

</tasks>

<verification>
1. `./gradlew build` passes
2. Code inspection confirms:
   - RevivalStatePayload follows BucklerStatePayload pattern
   - RevivalSync follows BucklerSync pattern with look-direction check
   - RevivalClientState follows BucklerClientState pattern
   - RevivalProgressRenderer renders empty texture as background
   - Filled texture rendered as radial pie using triangle fan
   - Progress fills clockwise from 12 o'clock (startAngle = -PI/2)
   - HUD element registered before crosshair
   - Payload registered for S2C communication
</verification>

<success_criteria>
- Radial progress ring appears centered on cursor when looking at downed location within 2 blocks
- Empty ring texture shows as background (0% or any progress)
- Filled ring fills radially clockwise from top based on progress percentage
- Ring disappears instantly when not looking at valid target
- Ring disappears when revival completes (server clears state)
- Uses existing textures (revival_progress_empty.png, revival_progress_full.png)
- All code compiles and builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/74-revival-ui/74-01-SUMMARY.md`
</output>
