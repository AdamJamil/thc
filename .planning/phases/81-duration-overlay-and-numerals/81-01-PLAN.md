---
phase: 81-duration-overlay-and-numerals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/client/kotlin/thc/client/EffectsHudRenderer.kt
autonomous: true

must_haves:
  truths:
    - "Green 50% transparent overlay fills from the bottom of the effect icon, height proportional to remaining duration"
    - "Duration overlay drains smoothly every tick with no visible stepping"
    - "Roman numeral (I through X) renders at 5px right and 5px down from top-left of frame for effects with amplifier >= 1"
    - "Effects appear instantly when applied and disappear instantly when expired or removed"
    - "Amplifier 0 shows no numeral, amplifier 1 shows II, amplifier 9 shows X"
  artifacts:
    - path: "src/client/kotlin/thc/client/EffectsHudRenderer.kt"
      provides: "Duration overlay and numeral rendering integrated into effect HUD"
      contains: "renderDurationOverlay"
  key_links:
    - from: "EffectsHudRenderer.kt"
      to: "MobEffectInstance"
      via: "getDuration() and getAmplifier() calls per effect each frame"
      pattern: "getDuration|getAmplifier"
    - from: "EffectsHudRenderer.kt"
      to: "numerals.png"
      via: "NUMERALS_TEXTURE Identifier blit with UV offsets per amplifier"
      pattern: "NUMERALS_TEXTURE"
---

<objective>
Add duration overlay and roman numeral rendering to the Effects HUD created in Phase 80.

Purpose: Players need to see at a glance how much time remains on each active effect (green fill draining from top to bottom) and the amplifier level (roman numeral in the top-left area of each frame). This also implements instant lifecycle behavior — effects appear/disappear without animation.

Output: Updated EffectsHudRenderer.kt with duration overlay and numeral rendering integrated into the per-effect render loop.
</objective>

<execution_context>
@/home/tack/.claude/get-shit-done/workflows/execute-plan.md
@/home/tack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v3.2-ROADMAP.md
@src/client/kotlin/thc/client/EffectsHudRenderer.kt
@src/client/kotlin/thc/client/BucklerHudRenderer.kt
@src/client/kotlin/thc/client/RevivalProgressRenderer.kt
@src/client/kotlin/thc/THCClient.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add duration overlay and numeral rendering to EffectsHudRenderer</name>
  <files>src/client/kotlin/thc/client/EffectsHudRenderer.kt</files>
  <action>
Modify the existing EffectsHudRenderer.kt (created in Phase 80) to add two rendering layers per effect inside the existing per-effect render loop. The Phase 80 renderer already iterates over sorted active effects and renders a frame + icon per effect. This task adds layers on top.

**Duration Overlay (FRAM-03, LIFE-02):**

After the icon is drawn for each effect, render a green semi-transparent rectangle covering the icon area from the bottom upward:

1. Get duration info from each MobEffectInstance:
   - `instance.getDuration()` returns remaining ticks
   - `instance.isInfiniteDuration()` returns true for infinite effects
   - For infinite effects, draw the overlay at full height (100%)
   - For timed effects, compute ratio: `remainingTicks / originalDuration`

2. **Original duration tracking:** MobEffectInstance only exposes remaining duration, not the original. To track the original duration for ratio calculation:
   - Add a `private val originalDurations = mutableMapOf<String, Int>()` keyed by effect registry name
   - When an effect is first seen (not in map) OR its duration is HIGHER than stored (re-applied/refreshed), store the current duration as original
   - When an effect disappears from the active set, remove its entry from the map
   - Ratio = `remainingDuration.toFloat() / originalDurations[key]!!.toFloat()`

3. **Render the overlay** using `GuiGraphics.fill()`:
   - The overlay covers the icon area (the 36x36 region centered in the 44x44 frame, so offset by 4px from frame edges)
   - Green color with 50% alpha: `0x8000FF00` (ARGB: alpha=0x80, R=0x00, G=0xFF, B=0x00)
   - The overlay height = `(36 * ratio).toInt()` pixels
   - The overlay is anchored at the BOTTOM of the icon area and fills UPWARD
   - So: `fill(iconX, iconY + 36 - overlayHeight, iconX + 36, iconY + 36, 0x8000FF00)`
   - Where `iconX = frameX + 4` and `iconY = frameY + 4` (4px border inside frame)

4. **Per-tick smoothness (LIFE-02):** Since the HUD renders every frame and getDuration() decreases every tick, the overlay height naturally updates smoothly. For sub-tick interpolation, use the partialTick value from the render callback:
   - `effectiveRemaining = remainingDuration - (1.0f - partialTick)` (where partialTick is the fractional tick passed to the render method)
   - Clamp to >= 0

**Important:** The `GuiGraphics.fill()` method in MC 1.21.11 draws a filled rectangle. The signature is `fill(int x1, int y1, int x2, int y2, int color)` where color is ARGB. However, by default fill does NOT respect alpha blending. You need to use the overload `fill(RenderPipeline, int x1, int y1, int x2, int y2, int color)` with `RenderPipelines.GUI_TEXTURED_OVERLAY` or alternatively use the method that accepts a RenderLayer. If `fill()` with plain ARGB does not produce transparency, switch approach:
   - Use `guiGraphics.fill(RenderPipelines.GUI, x1, y1, x2, y2, 0x8000FF00)` — the GUI pipeline supports alpha blending
   - If that doesn't work either, use a 1x1 green pixel texture and blit it stretched to the overlay dimensions with `setColor` alpha

**Roman Numeral Rendering (FRAM-04):**

After the duration overlay, render the amplifier level as a roman numeral:

1. Get amplifier from `instance.getAmplifier()`:
   - Amplifier 0 = level I (but do NOT render for level I — only render II through X)
   - Amplifier 1 = level II (numeral index 1 in spritesheet)
   - Amplifier 9 = level X (numeral index 9)
   - Skip rendering if amplifier == 0

2. **Numeral spritesheet layout** (numerals.png):
   - The texture is a vertical strip: 13px wide, 90px tall (10 numerals stacked)
   - Each numeral subsection is 13x9 pixels
   - Numeral I is at v=0, II at v=9, III at v=18, etc.
   - For amplifier `a` (0-indexed where 0=I): UV offset v = `a * 9`
   - Since we skip amplifier 0, for amplifier `a >= 1`: render numeral at v = `a * 9`

3. **Position:** 5px right and 5px down from the top-left corner of the frame
   - `numeralX = frameX + 5`
   - `numeralY = frameY + 5`

4. **Blit call:**
   ```kotlin
   val NUMERALS_TEXTURE = Identifier.fromNamespaceAndPath("thc", "textures/item/numerals.png")
   // ...
   guiGraphics.blit(
       RenderPipelines.GUI_TEXTURED,
       NUMERALS_TEXTURE,
       numeralX, numeralY,
       0.0f,                    // u offset (always 0, single column)
       (amplifier * 9).toFloat(), // v offset based on amplifier
       13, 9,                   // render width, height
       13, 90                   // texture total width, height (13x90 for 10 numerals)
   )
   ```

**Lifecycle (LIFE-01):**

Effects appearing/disappearing instantly is the DEFAULT behavior since the render loop simply iterates over `player.getActiveEffects()` each frame. No animation code, no fade-in/fade-out. If an effect is in the collection, it renders. If not, it doesn't. This is already handled by Phase 80's design. Just verify that no transition animations were added.

**Method signature update:**

The Phase 80 renderer's `render()` function receives `guiGraphics: GuiGraphics`. If the partialTick parameter is not already available, add it as a parameter or retrieve it from `Minecraft.getInstance().timer.partialTick` (MC 1.21.11) or `Minecraft.getInstance().deltaTracker.getGameTimeDeltaPartialTick(false)`.

**Cleanup of originalDurations map:**

At the start of each render call, build a set of currently active effect keys. After rendering, remove any entries from `originalDurations` that are NOT in the active set. This ensures the map stays clean and doesn't accumulate stale entries.
  </action>
  <verify>
Run `./gradlew build` to confirm compilation succeeds. Then verify in-game:
1. Apply a timed effect (e.g., drink a potion of speed) — green overlay should fill the icon area and drain downward as time passes
2. Apply an effect with amplifier >= 2 (e.g., Strength II) — roman numeral "II" should appear at top-left of frame
3. Let an effect expire — it should vanish instantly with no fade
4. Check that amplifier I effects show no numeral
5. Confirm overlay height updates every tick (smooth drain, no stepping)
  </verify>
  <done>
Green 50% transparent overlay fills bottom-up proportional to remaining duration, drains smoothly per tick. Roman numerals II-X render at (frameX+5, frameY+5) from numerals.png spritesheet. Amplifier I shows no numeral. Effects appear/disappear instantly. originalDurations map tracks and cleans up properly.
  </done>
</task>

</tasks>

<verification>
1. **Green overlay:** Apply Poison (30s) — watch overlay height decrease smoothly from full to empty over 30 seconds
2. **Overlay transparency:** Background icon should be partially visible through the green overlay (50% alpha)
3. **Infinite effects:** Apply an infinite effect via command (`/effect give @s resistance infinite`) — overlay should show at 100% height and never drain
4. **Numeral rendering:** `/effect give @s strength 60 2` — should show "III" numeral (amplifier 2 = level III)
5. **No numeral for level I:** `/effect give @s speed 60 0` — should show NO numeral (amplifier 0 = level I)
6. **Lifecycle:** Remove effect with `/effect clear @s speed` — should vanish instantly
7. **Effect refresh:** While speed is active, re-apply with `/effect give @s speed 60` — original duration should reset, overlay should jump back to full
8. **Compilation:** `./gradlew build` passes with no errors
</verification>

<success_criteria>
- Green 50% transparent overlay renders from bottom of icon area, height proportional to remaining/original duration ratio
- Overlay updates smoothly every tick (sub-tick interpolation with partialTick)
- Roman numeral from numerals.png spritesheet renders at 5px right, 5px down from frame top-left for amplifier >= 1
- Amplifier 0 (level I) shows no numeral
- Effects appear when applied, disappear when expired — no transition animations
- originalDurations map is maintained and cleaned up each frame
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/81-duration-overlay-and-numerals/81-01-SUMMARY.md`
</output>
